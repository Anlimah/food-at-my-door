<?php
/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Food Delivery API
 *
 * API for managing restaurants, menus, orders, and deliveries in a food delivery app
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'categoriesCategoryIdDelete' => [
            'application/json',
        ],
        'categoriesCategoryIdGet' => [
            'application/json',
        ],
        'categoriesCategoryIdPut' => [
            'application/json',
        ],
        'categoriesGet' => [
            'application/json',
        ],
        'categoriesPost' => [
            'application/json',
        ],
        'customersCustomerIdDelete' => [
            'application/json',
        ],
        'customersCustomerIdGet' => [
            'application/json',
        ],
        'customersCustomerIdPut' => [
            'application/json',
        ],
        'customersGet' => [
            'application/json',
        ],
        'customersPost' => [
            'application/json',
        ],
        'discountsDiscountIdDelete' => [
            'application/json',
        ],
        'discountsDiscountIdGet' => [
            'application/json',
        ],
        'discountsDiscountIdPut' => [
            'application/json',
        ],
        'discountsGet' => [
            'application/json',
        ],
        'discountsPost' => [
            'application/json',
        ],
        'ingredientsGet' => [
            'application/json',
        ],
        'ingredientsIngredientIdDelete' => [
            'application/json',
        ],
        'ingredientsIngredientIdGet' => [
            'application/json',
        ],
        'ingredientsIngredientIdPut' => [
            'application/json',
        ],
        'ingredientsPost' => [
            'application/json',
        ],
        'menuItemCategoriesCategoryIdDelete' => [
            'application/json',
        ],
        'menuItemCategoriesCategoryIdGet' => [
            'application/json',
        ],
        'menuItemCategoriesCategoryIdPut' => [
            'application/json',
        ],
        'menuItemCategoriesGet' => [
            'application/json',
        ],
        'menuItemCategoriesPost' => [
            'application/json',
        ],
        'menuItemOptionsGet' => [
            'application/json',
        ],
        'menuItemOptionsOptionIdDelete' => [
            'application/json',
        ],
        'menuItemOptionsOptionIdGet' => [
            'application/json',
        ],
        'menuItemOptionsOptionIdPut' => [
            'application/json',
        ],
        'menuItemOptionsPost' => [
            'application/json',
        ],
        'menuItemsGet' => [
            'application/json',
        ],
        'menuItemsItemIdDelete' => [
            'application/json',
        ],
        'menuItemsItemIdGet' => [
            'application/json',
        ],
        'menuItemsItemIdPut' => [
            'application/json',
        ],
        'menuItemsPost' => [
            'application/json',
        ],
        'orderItemsGet' => [
            'application/json',
        ],
        'orderItemsItemIdDelete' => [
            'application/json',
        ],
        'orderItemsItemIdGet' => [
            'application/json',
        ],
        'orderItemsItemIdPut' => [
            'application/json',
        ],
        'orderItemsPost' => [
            'application/json',
        ],
        'ordersGet' => [
            'application/json',
        ],
        'ordersOrderIdDelete' => [
            'application/json',
        ],
        'ordersOrderIdGet' => [
            'application/json',
        ],
        'ordersOrderIdPut' => [
            'application/json',
        ],
        'ordersPost' => [
            'application/json',
        ],
        'reportsComponentItemGet' => [
            'application/json',
        ],
        'reportsCustomersAverageOrderFrequencyGet' => [
            'application/json',
        ],
        'reportsCustomersRetentionGet' => [
            'application/json',
        ],
        'reportsCustomersTotalGet' => [
            'application/json',
        ],
        'reportsDiscountsEffectivenessGet' => [
            'application/json',
        ],
        'reportsDiscountsRevenueImpactGet' => [
            'application/json',
        ],
        'reportsDiscountsUsageGet' => [
            'application/json',
        ],
        'reportsGet' => [
            'application/json',
        ],
        'reportsMenusPopularityGet' => [
            'application/json',
        ],
        'reportsOrdersAverageValueGet' => [
            'application/json',
        ],
        'reportsOrdersFulfillmentTimeGet' => [
            'application/json',
        ],
        'reportsOrdersTotalGet' => [
            'application/json',
        ],
        'reportsPost' => [
            'application/json',
        ],
        'reportsReportIdDelete' => [
            'application/json',
        ],
        'reportsReportIdGet' => [
            'application/json',
        ],
        'reportsReportIdPut' => [
            'application/json',
        ],
        'reportsRestaurantsOrdersGet' => [
            'application/json',
        ],
        'reportsRestaurantsRatingsGet' => [
            'application/json',
        ],
        'reportsRestaurantsRevenueGet' => [
            'application/json',
        ],
        'restaurantsGet' => [
            'application/json',
        ],
        'restaurantsPost' => [
            'multipart/form-data',
        ],
        'restaurantsRestaurantIdDelete' => [
            'application/json',
        ],
        'restaurantsRestaurantIdGet' => [
            'application/json',
        ],
        'restaurantsRestaurantIdMenusGet' => [
            'application/json',
        ],
        'restaurantsRestaurantIdMenusMenuIdDelete' => [
            'application/json',
        ],
        'restaurantsRestaurantIdMenusMenuIdGet' => [
            'application/json',
        ],
        'restaurantsRestaurantIdMenusMenuIdPut' => [
            'multipart/form-data',
        ],
        'restaurantsRestaurantIdMenusPost' => [
            'multipart/form-data',
        ],
        'restaurantsRestaurantIdPut' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation categoriesCategoryIdDelete
     *
     * Delete a category
     *
     * @param  string $category_id category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function categoriesCategoryIdDelete($category_id, string $contentType = self::contentTypes['categoriesCategoryIdDelete'][0])
    {
        $this->categoriesCategoryIdDeleteWithHttpInfo($category_id, $contentType);
    }

    /**
     * Operation categoriesCategoryIdDeleteWithHttpInfo
     *
     * Delete a category
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoriesCategoryIdDeleteWithHttpInfo($category_id, string $contentType = self::contentTypes['categoriesCategoryIdDelete'][0])
    {
        $request = $this->categoriesCategoryIdDeleteRequest($category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation categoriesCategoryIdDeleteAsync
     *
     * Delete a category
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesCategoryIdDeleteAsync($category_id, string $contentType = self::contentTypes['categoriesCategoryIdDelete'][0])
    {
        return $this->categoriesCategoryIdDeleteAsyncWithHttpInfo($category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoriesCategoryIdDeleteAsyncWithHttpInfo
     *
     * Delete a category
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesCategoryIdDeleteAsyncWithHttpInfo($category_id, string $contentType = self::contentTypes['categoriesCategoryIdDelete'][0])
    {
        $returnType = '';
        $request = $this->categoriesCategoryIdDeleteRequest($category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoriesCategoryIdDelete'
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function categoriesCategoryIdDeleteRequest($category_id, string $contentType = self::contentTypes['categoriesCategoryIdDelete'][0])
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling categoriesCategoryIdDelete'
            );
        }


        $resourcePath = '/categories/{categoryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoriesCategoryIdGet
     *
     * Get a category by ID
     *
     * @param  string $category_id category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Category
     */
    public function categoriesCategoryIdGet($category_id, string $contentType = self::contentTypes['categoriesCategoryIdGet'][0])
    {
        list($response) = $this->categoriesCategoryIdGetWithHttpInfo($category_id, $contentType);
        return $response;
    }

    /**
     * Operation categoriesCategoryIdGetWithHttpInfo
     *
     * Get a category by ID
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoriesCategoryIdGetWithHttpInfo($category_id, string $contentType = self::contentTypes['categoriesCategoryIdGet'][0])
    {
        $request = $this->categoriesCategoryIdGetRequest($category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Category' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Category' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Category', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Category';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoriesCategoryIdGetAsync
     *
     * Get a category by ID
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesCategoryIdGetAsync($category_id, string $contentType = self::contentTypes['categoriesCategoryIdGet'][0])
    {
        return $this->categoriesCategoryIdGetAsyncWithHttpInfo($category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoriesCategoryIdGetAsyncWithHttpInfo
     *
     * Get a category by ID
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesCategoryIdGetAsyncWithHttpInfo($category_id, string $contentType = self::contentTypes['categoriesCategoryIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Category';
        $request = $this->categoriesCategoryIdGetRequest($category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoriesCategoryIdGet'
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function categoriesCategoryIdGetRequest($category_id, string $contentType = self::contentTypes['categoriesCategoryIdGet'][0])
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling categoriesCategoryIdGet'
            );
        }


        $resourcePath = '/categories/{categoryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoriesCategoryIdPut
     *
     * Update a category
     *
     * @param  string $category_id category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCategory $update_category update_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function categoriesCategoryIdPut($category_id, $update_category, string $contentType = self::contentTypes['categoriesCategoryIdPut'][0])
    {
        $this->categoriesCategoryIdPutWithHttpInfo($category_id, $update_category, $contentType);
    }

    /**
     * Operation categoriesCategoryIdPutWithHttpInfo
     *
     * Update a category
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCategory $update_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoriesCategoryIdPutWithHttpInfo($category_id, $update_category, string $contentType = self::contentTypes['categoriesCategoryIdPut'][0])
    {
        $request = $this->categoriesCategoryIdPutRequest($category_id, $update_category, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation categoriesCategoryIdPutAsync
     *
     * Update a category
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCategory $update_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesCategoryIdPutAsync($category_id, $update_category, string $contentType = self::contentTypes['categoriesCategoryIdPut'][0])
    {
        return $this->categoriesCategoryIdPutAsyncWithHttpInfo($category_id, $update_category, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoriesCategoryIdPutAsyncWithHttpInfo
     *
     * Update a category
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCategory $update_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesCategoryIdPutAsyncWithHttpInfo($category_id, $update_category, string $contentType = self::contentTypes['categoriesCategoryIdPut'][0])
    {
        $returnType = '';
        $request = $this->categoriesCategoryIdPutRequest($category_id, $update_category, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoriesCategoryIdPut'
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCategory $update_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function categoriesCategoryIdPutRequest($category_id, $update_category, string $contentType = self::contentTypes['categoriesCategoryIdPut'][0])
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling categoriesCategoryIdPut'
            );
        }

        // verify the required parameter 'update_category' is set
        if ($update_category === null || (is_array($update_category) && count($update_category) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_category when calling categoriesCategoryIdPut'
            );
        }


        $resourcePath = '/categories/{categoryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_category)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_category));
            } else {
                $httpBody = $update_category;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoriesGet
     *
     * Get all categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Category[]
     */
    public function categoriesGet(string $contentType = self::contentTypes['categoriesGet'][0])
    {
        list($response) = $this->categoriesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation categoriesGetWithHttpInfo
     *
     * Get all categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Category[], HTTP status code, HTTP response headers (array of strings)
     */
    public function categoriesGetWithHttpInfo(string $contentType = self::contentTypes['categoriesGet'][0])
    {
        $request = $this->categoriesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Category[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Category[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Category[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Category[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Category[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoriesGetAsync
     *
     * Get all categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesGetAsync(string $contentType = self::contentTypes['categoriesGet'][0])
    {
        return $this->categoriesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoriesGetAsyncWithHttpInfo
     *
     * Get all categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['categoriesGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Category[]';
        $request = $this->categoriesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoriesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function categoriesGetRequest(string $contentType = self::contentTypes['categoriesGet'][0])
    {


        $resourcePath = '/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoriesPost
     *
     * Create a new category
     *
     * @param  \OpenAPI\Client\Model\NewCategory $new_category new_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function categoriesPost($new_category, string $contentType = self::contentTypes['categoriesPost'][0])
    {
        $this->categoriesPostWithHttpInfo($new_category, $contentType);
    }

    /**
     * Operation categoriesPostWithHttpInfo
     *
     * Create a new category
     *
     * @param  \OpenAPI\Client\Model\NewCategory $new_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoriesPostWithHttpInfo($new_category, string $contentType = self::contentTypes['categoriesPost'][0])
    {
        $request = $this->categoriesPostRequest($new_category, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation categoriesPostAsync
     *
     * Create a new category
     *
     * @param  \OpenAPI\Client\Model\NewCategory $new_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesPostAsync($new_category, string $contentType = self::contentTypes['categoriesPost'][0])
    {
        return $this->categoriesPostAsyncWithHttpInfo($new_category, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoriesPostAsyncWithHttpInfo
     *
     * Create a new category
     *
     * @param  \OpenAPI\Client\Model\NewCategory $new_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoriesPostAsyncWithHttpInfo($new_category, string $contentType = self::contentTypes['categoriesPost'][0])
    {
        $returnType = '';
        $request = $this->categoriesPostRequest($new_category, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoriesPost'
     *
     * @param  \OpenAPI\Client\Model\NewCategory $new_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function categoriesPostRequest($new_category, string $contentType = self::contentTypes['categoriesPost'][0])
    {

        // verify the required parameter 'new_category' is set
        if ($new_category === null || (is_array($new_category) && count($new_category) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_category when calling categoriesPost'
            );
        }


        $resourcePath = '/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_category)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_category));
            } else {
                $httpBody = $new_category;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersCustomerIdDelete
     *
     * Delete a customer
     *
     * @param  string $customer_id customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customersCustomerIdDelete($customer_id, string $contentType = self::contentTypes['customersCustomerIdDelete'][0])
    {
        $this->customersCustomerIdDeleteWithHttpInfo($customer_id, $contentType);
    }

    /**
     * Operation customersCustomerIdDeleteWithHttpInfo
     *
     * Delete a customer
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersCustomerIdDeleteWithHttpInfo($customer_id, string $contentType = self::contentTypes['customersCustomerIdDelete'][0])
    {
        $request = $this->customersCustomerIdDeleteRequest($customer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation customersCustomerIdDeleteAsync
     *
     * Delete a customer
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdDeleteAsync($customer_id, string $contentType = self::contentTypes['customersCustomerIdDelete'][0])
    {
        return $this->customersCustomerIdDeleteAsyncWithHttpInfo($customer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersCustomerIdDeleteAsyncWithHttpInfo
     *
     * Delete a customer
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdDeleteAsyncWithHttpInfo($customer_id, string $contentType = self::contentTypes['customersCustomerIdDelete'][0])
    {
        $returnType = '';
        $request = $this->customersCustomerIdDeleteRequest($customer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersCustomerIdDelete'
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customersCustomerIdDeleteRequest($customer_id, string $contentType = self::contentTypes['customersCustomerIdDelete'][0])
    {

        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling customersCustomerIdDelete'
            );
        }


        $resourcePath = '/customers/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersCustomerIdGet
     *
     * Get a customer by ID
     *
     * @param  string $customer_id customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Customer
     */
    public function customersCustomerIdGet($customer_id, string $contentType = self::contentTypes['customersCustomerIdGet'][0])
    {
        list($response) = $this->customersCustomerIdGetWithHttpInfo($customer_id, $contentType);
        return $response;
    }

    /**
     * Operation customersCustomerIdGetWithHttpInfo
     *
     * Get a customer by ID
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersCustomerIdGetWithHttpInfo($customer_id, string $contentType = self::contentTypes['customersCustomerIdGet'][0])
    {
        $request = $this->customersCustomerIdGetRequest($customer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Customer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Customer' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Customer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Customer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersCustomerIdGetAsync
     *
     * Get a customer by ID
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdGetAsync($customer_id, string $contentType = self::contentTypes['customersCustomerIdGet'][0])
    {
        return $this->customersCustomerIdGetAsyncWithHttpInfo($customer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersCustomerIdGetAsyncWithHttpInfo
     *
     * Get a customer by ID
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdGetAsyncWithHttpInfo($customer_id, string $contentType = self::contentTypes['customersCustomerIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Customer';
        $request = $this->customersCustomerIdGetRequest($customer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersCustomerIdGet'
     *
     * @param  string $customer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customersCustomerIdGetRequest($customer_id, string $contentType = self::contentTypes['customersCustomerIdGet'][0])
    {

        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling customersCustomerIdGet'
            );
        }


        $resourcePath = '/customers/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersCustomerIdPut
     *
     * Update a customer
     *
     * @param  string $customer_id customer_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCustomer $update_customer update_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customersCustomerIdPut($customer_id, $update_customer, string $contentType = self::contentTypes['customersCustomerIdPut'][0])
    {
        $this->customersCustomerIdPutWithHttpInfo($customer_id, $update_customer, $contentType);
    }

    /**
     * Operation customersCustomerIdPutWithHttpInfo
     *
     * Update a customer
     *
     * @param  string $customer_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCustomer $update_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersCustomerIdPutWithHttpInfo($customer_id, $update_customer, string $contentType = self::contentTypes['customersCustomerIdPut'][0])
    {
        $request = $this->customersCustomerIdPutRequest($customer_id, $update_customer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation customersCustomerIdPutAsync
     *
     * Update a customer
     *
     * @param  string $customer_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCustomer $update_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdPutAsync($customer_id, $update_customer, string $contentType = self::contentTypes['customersCustomerIdPut'][0])
    {
        return $this->customersCustomerIdPutAsyncWithHttpInfo($customer_id, $update_customer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersCustomerIdPutAsyncWithHttpInfo
     *
     * Update a customer
     *
     * @param  string $customer_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCustomer $update_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersCustomerIdPutAsyncWithHttpInfo($customer_id, $update_customer, string $contentType = self::contentTypes['customersCustomerIdPut'][0])
    {
        $returnType = '';
        $request = $this->customersCustomerIdPutRequest($customer_id, $update_customer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersCustomerIdPut'
     *
     * @param  string $customer_id (required)
     * @param  \OpenAPI\Client\Model\UpdateCustomer $update_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersCustomerIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customersCustomerIdPutRequest($customer_id, $update_customer, string $contentType = self::contentTypes['customersCustomerIdPut'][0])
    {

        // verify the required parameter 'customer_id' is set
        if ($customer_id === null || (is_array($customer_id) && count($customer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_id when calling customersCustomerIdPut'
            );
        }

        // verify the required parameter 'update_customer' is set
        if ($update_customer === null || (is_array($update_customer) && count($update_customer) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_customer when calling customersCustomerIdPut'
            );
        }


        $resourcePath = '/customers/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($customer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerId' . '}',
                ObjectSerializer::toPathValue($customer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_customer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_customer));
            } else {
                $httpBody = $update_customer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersGet
     *
     * Get all customers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Customer[]
     */
    public function customersGet(string $contentType = self::contentTypes['customersGet'][0])
    {
        list($response) = $this->customersGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation customersGetWithHttpInfo
     *
     * Get all customers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Customer[], HTTP status code, HTTP response headers (array of strings)
     */
    public function customersGetWithHttpInfo(string $contentType = self::contentTypes['customersGet'][0])
    {
        $request = $this->customersGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Customer[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Customer[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Customer[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Customer[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Customer[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersGetAsync
     *
     * Get all customers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersGetAsync(string $contentType = self::contentTypes['customersGet'][0])
    {
        return $this->customersGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersGetAsyncWithHttpInfo
     *
     * Get all customers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersGetAsyncWithHttpInfo(string $contentType = self::contentTypes['customersGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Customer[]';
        $request = $this->customersGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customersGetRequest(string $contentType = self::contentTypes['customersGet'][0])
    {


        $resourcePath = '/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersPost
     *
     * Create a new customer
     *
     * @param  \OpenAPI\Client\Model\NewCustomer $new_customer new_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customersPost($new_customer, string $contentType = self::contentTypes['customersPost'][0])
    {
        $this->customersPostWithHttpInfo($new_customer, $contentType);
    }

    /**
     * Operation customersPostWithHttpInfo
     *
     * Create a new customer
     *
     * @param  \OpenAPI\Client\Model\NewCustomer $new_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersPostWithHttpInfo($new_customer, string $contentType = self::contentTypes['customersPost'][0])
    {
        $request = $this->customersPostRequest($new_customer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation customersPostAsync
     *
     * Create a new customer
     *
     * @param  \OpenAPI\Client\Model\NewCustomer $new_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersPostAsync($new_customer, string $contentType = self::contentTypes['customersPost'][0])
    {
        return $this->customersPostAsyncWithHttpInfo($new_customer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersPostAsyncWithHttpInfo
     *
     * Create a new customer
     *
     * @param  \OpenAPI\Client\Model\NewCustomer $new_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersPostAsyncWithHttpInfo($new_customer, string $contentType = self::contentTypes['customersPost'][0])
    {
        $returnType = '';
        $request = $this->customersPostRequest($new_customer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersPost'
     *
     * @param  \OpenAPI\Client\Model\NewCustomer $new_customer (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customersPostRequest($new_customer, string $contentType = self::contentTypes['customersPost'][0])
    {

        // verify the required parameter 'new_customer' is set
        if ($new_customer === null || (is_array($new_customer) && count($new_customer) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_customer when calling customersPost'
            );
        }


        $resourcePath = '/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_customer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_customer));
            } else {
                $httpBody = $new_customer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discountsDiscountIdDelete
     *
     * Delete a discount
     *
     * @param  string $discount_id discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function discountsDiscountIdDelete($discount_id, string $contentType = self::contentTypes['discountsDiscountIdDelete'][0])
    {
        $this->discountsDiscountIdDeleteWithHttpInfo($discount_id, $contentType);
    }

    /**
     * Operation discountsDiscountIdDeleteWithHttpInfo
     *
     * Delete a discount
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function discountsDiscountIdDeleteWithHttpInfo($discount_id, string $contentType = self::contentTypes['discountsDiscountIdDelete'][0])
    {
        $request = $this->discountsDiscountIdDeleteRequest($discount_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation discountsDiscountIdDeleteAsync
     *
     * Delete a discount
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsDiscountIdDeleteAsync($discount_id, string $contentType = self::contentTypes['discountsDiscountIdDelete'][0])
    {
        return $this->discountsDiscountIdDeleteAsyncWithHttpInfo($discount_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discountsDiscountIdDeleteAsyncWithHttpInfo
     *
     * Delete a discount
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsDiscountIdDeleteAsyncWithHttpInfo($discount_id, string $contentType = self::contentTypes['discountsDiscountIdDelete'][0])
    {
        $returnType = '';
        $request = $this->discountsDiscountIdDeleteRequest($discount_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discountsDiscountIdDelete'
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discountsDiscountIdDeleteRequest($discount_id, string $contentType = self::contentTypes['discountsDiscountIdDelete'][0])
    {

        // verify the required parameter 'discount_id' is set
        if ($discount_id === null || (is_array($discount_id) && count($discount_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discount_id when calling discountsDiscountIdDelete'
            );
        }


        $resourcePath = '/discounts/{discountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($discount_id !== null) {
            $resourcePath = str_replace(
                '{' . 'discountId' . '}',
                ObjectSerializer::toPathValue($discount_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discountsDiscountIdGet
     *
     * Get a discount by ID
     *
     * @param  string $discount_id discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Discount
     */
    public function discountsDiscountIdGet($discount_id, string $contentType = self::contentTypes['discountsDiscountIdGet'][0])
    {
        list($response) = $this->discountsDiscountIdGetWithHttpInfo($discount_id, $contentType);
        return $response;
    }

    /**
     * Operation discountsDiscountIdGetWithHttpInfo
     *
     * Get a discount by ID
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Discount, HTTP status code, HTTP response headers (array of strings)
     */
    public function discountsDiscountIdGetWithHttpInfo($discount_id, string $contentType = self::contentTypes['discountsDiscountIdGet'][0])
    {
        $request = $this->discountsDiscountIdGetRequest($discount_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Discount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Discount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Discount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Discount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Discount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation discountsDiscountIdGetAsync
     *
     * Get a discount by ID
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsDiscountIdGetAsync($discount_id, string $contentType = self::contentTypes['discountsDiscountIdGet'][0])
    {
        return $this->discountsDiscountIdGetAsyncWithHttpInfo($discount_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discountsDiscountIdGetAsyncWithHttpInfo
     *
     * Get a discount by ID
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsDiscountIdGetAsyncWithHttpInfo($discount_id, string $contentType = self::contentTypes['discountsDiscountIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Discount';
        $request = $this->discountsDiscountIdGetRequest($discount_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discountsDiscountIdGet'
     *
     * @param  string $discount_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discountsDiscountIdGetRequest($discount_id, string $contentType = self::contentTypes['discountsDiscountIdGet'][0])
    {

        // verify the required parameter 'discount_id' is set
        if ($discount_id === null || (is_array($discount_id) && count($discount_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discount_id when calling discountsDiscountIdGet'
            );
        }


        $resourcePath = '/discounts/{discountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($discount_id !== null) {
            $resourcePath = str_replace(
                '{' . 'discountId' . '}',
                ObjectSerializer::toPathValue($discount_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discountsDiscountIdPut
     *
     * Update a discount
     *
     * @param  string $discount_id discount_id (required)
     * @param  \OpenAPI\Client\Model\UpdateDiscount $update_discount update_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function discountsDiscountIdPut($discount_id, $update_discount, string $contentType = self::contentTypes['discountsDiscountIdPut'][0])
    {
        $this->discountsDiscountIdPutWithHttpInfo($discount_id, $update_discount, $contentType);
    }

    /**
     * Operation discountsDiscountIdPutWithHttpInfo
     *
     * Update a discount
     *
     * @param  string $discount_id (required)
     * @param  \OpenAPI\Client\Model\UpdateDiscount $update_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function discountsDiscountIdPutWithHttpInfo($discount_id, $update_discount, string $contentType = self::contentTypes['discountsDiscountIdPut'][0])
    {
        $request = $this->discountsDiscountIdPutRequest($discount_id, $update_discount, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation discountsDiscountIdPutAsync
     *
     * Update a discount
     *
     * @param  string $discount_id (required)
     * @param  \OpenAPI\Client\Model\UpdateDiscount $update_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsDiscountIdPutAsync($discount_id, $update_discount, string $contentType = self::contentTypes['discountsDiscountIdPut'][0])
    {
        return $this->discountsDiscountIdPutAsyncWithHttpInfo($discount_id, $update_discount, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discountsDiscountIdPutAsyncWithHttpInfo
     *
     * Update a discount
     *
     * @param  string $discount_id (required)
     * @param  \OpenAPI\Client\Model\UpdateDiscount $update_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsDiscountIdPutAsyncWithHttpInfo($discount_id, $update_discount, string $contentType = self::contentTypes['discountsDiscountIdPut'][0])
    {
        $returnType = '';
        $request = $this->discountsDiscountIdPutRequest($discount_id, $update_discount, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discountsDiscountIdPut'
     *
     * @param  string $discount_id (required)
     * @param  \OpenAPI\Client\Model\UpdateDiscount $update_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsDiscountIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discountsDiscountIdPutRequest($discount_id, $update_discount, string $contentType = self::contentTypes['discountsDiscountIdPut'][0])
    {

        // verify the required parameter 'discount_id' is set
        if ($discount_id === null || (is_array($discount_id) && count($discount_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discount_id when calling discountsDiscountIdPut'
            );
        }

        // verify the required parameter 'update_discount' is set
        if ($update_discount === null || (is_array($update_discount) && count($update_discount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_discount when calling discountsDiscountIdPut'
            );
        }


        $resourcePath = '/discounts/{discountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($discount_id !== null) {
            $resourcePath = str_replace(
                '{' . 'discountId' . '}',
                ObjectSerializer::toPathValue($discount_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_discount)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_discount));
            } else {
                $httpBody = $update_discount;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discountsGet
     *
     * Get all discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Discount[]
     */
    public function discountsGet(string $contentType = self::contentTypes['discountsGet'][0])
    {
        list($response) = $this->discountsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation discountsGetWithHttpInfo
     *
     * Get all discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Discount[], HTTP status code, HTTP response headers (array of strings)
     */
    public function discountsGetWithHttpInfo(string $contentType = self::contentTypes['discountsGet'][0])
    {
        $request = $this->discountsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Discount[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Discount[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Discount[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Discount[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Discount[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation discountsGetAsync
     *
     * Get all discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsGetAsync(string $contentType = self::contentTypes['discountsGet'][0])
    {
        return $this->discountsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discountsGetAsyncWithHttpInfo
     *
     * Get all discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['discountsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Discount[]';
        $request = $this->discountsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discountsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discountsGetRequest(string $contentType = self::contentTypes['discountsGet'][0])
    {


        $resourcePath = '/discounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discountsPost
     *
     * Create a new discount
     *
     * @param  \OpenAPI\Client\Model\NewDiscount $new_discount new_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function discountsPost($new_discount, string $contentType = self::contentTypes['discountsPost'][0])
    {
        $this->discountsPostWithHttpInfo($new_discount, $contentType);
    }

    /**
     * Operation discountsPostWithHttpInfo
     *
     * Create a new discount
     *
     * @param  \OpenAPI\Client\Model\NewDiscount $new_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function discountsPostWithHttpInfo($new_discount, string $contentType = self::contentTypes['discountsPost'][0])
    {
        $request = $this->discountsPostRequest($new_discount, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation discountsPostAsync
     *
     * Create a new discount
     *
     * @param  \OpenAPI\Client\Model\NewDiscount $new_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsPostAsync($new_discount, string $contentType = self::contentTypes['discountsPost'][0])
    {
        return $this->discountsPostAsyncWithHttpInfo($new_discount, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discountsPostAsyncWithHttpInfo
     *
     * Create a new discount
     *
     * @param  \OpenAPI\Client\Model\NewDiscount $new_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discountsPostAsyncWithHttpInfo($new_discount, string $contentType = self::contentTypes['discountsPost'][0])
    {
        $returnType = '';
        $request = $this->discountsPostRequest($new_discount, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discountsPost'
     *
     * @param  \OpenAPI\Client\Model\NewDiscount $new_discount (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discountsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discountsPostRequest($new_discount, string $contentType = self::contentTypes['discountsPost'][0])
    {

        // verify the required parameter 'new_discount' is set
        if ($new_discount === null || (is_array($new_discount) && count($new_discount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_discount when calling discountsPost'
            );
        }


        $resourcePath = '/discounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_discount)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_discount));
            } else {
                $httpBody = $new_discount;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientsGet
     *
     * Get all ingredients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Ingredient[]
     */
    public function ingredientsGet(string $contentType = self::contentTypes['ingredientsGet'][0])
    {
        list($response) = $this->ingredientsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation ingredientsGetWithHttpInfo
     *
     * Get all ingredients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Ingredient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientsGetWithHttpInfo(string $contentType = self::contentTypes['ingredientsGet'][0])
    {
        $request = $this->ingredientsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Ingredient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Ingredient[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Ingredient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Ingredient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Ingredient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientsGetAsync
     *
     * Get all ingredients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsGetAsync(string $contentType = self::contentTypes['ingredientsGet'][0])
    {
        return $this->ingredientsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientsGetAsyncWithHttpInfo
     *
     * Get all ingredients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['ingredientsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Ingredient[]';
        $request = $this->ingredientsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientsGetRequest(string $contentType = self::contentTypes['ingredientsGet'][0])
    {


        $resourcePath = '/ingredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientsIngredientIdDelete
     *
     * Delete an ingredient
     *
     * @param  string $ingredient_id ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ingredientsIngredientIdDelete($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdDelete'][0])
    {
        $this->ingredientsIngredientIdDeleteWithHttpInfo($ingredient_id, $contentType);
    }

    /**
     * Operation ingredientsIngredientIdDeleteWithHttpInfo
     *
     * Delete an ingredient
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientsIngredientIdDeleteWithHttpInfo($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdDelete'][0])
    {
        $request = $this->ingredientsIngredientIdDeleteRequest($ingredient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientsIngredientIdDeleteAsync
     *
     * Delete an ingredient
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsIngredientIdDeleteAsync($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdDelete'][0])
    {
        return $this->ingredientsIngredientIdDeleteAsyncWithHttpInfo($ingredient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientsIngredientIdDeleteAsyncWithHttpInfo
     *
     * Delete an ingredient
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsIngredientIdDeleteAsyncWithHttpInfo($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdDelete'][0])
    {
        $returnType = '';
        $request = $this->ingredientsIngredientIdDeleteRequest($ingredient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientsIngredientIdDelete'
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientsIngredientIdDeleteRequest($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdDelete'][0])
    {

        // verify the required parameter 'ingredient_id' is set
        if ($ingredient_id === null || (is_array($ingredient_id) && count($ingredient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_id when calling ingredientsIngredientIdDelete'
            );
        }


        $resourcePath = '/ingredients/{ingredientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($ingredient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ingredientId' . '}',
                ObjectSerializer::toPathValue($ingredient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientsIngredientIdGet
     *
     * Get an ingredient by ID
     *
     * @param  string $ingredient_id ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Ingredient
     */
    public function ingredientsIngredientIdGet($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdGet'][0])
    {
        list($response) = $this->ingredientsIngredientIdGetWithHttpInfo($ingredient_id, $contentType);
        return $response;
    }

    /**
     * Operation ingredientsIngredientIdGetWithHttpInfo
     *
     * Get an ingredient by ID
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Ingredient, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientsIngredientIdGetWithHttpInfo($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdGet'][0])
    {
        $request = $this->ingredientsIngredientIdGetRequest($ingredient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Ingredient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Ingredient' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Ingredient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Ingredient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Ingredient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientsIngredientIdGetAsync
     *
     * Get an ingredient by ID
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsIngredientIdGetAsync($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdGet'][0])
    {
        return $this->ingredientsIngredientIdGetAsyncWithHttpInfo($ingredient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientsIngredientIdGetAsyncWithHttpInfo
     *
     * Get an ingredient by ID
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsIngredientIdGetAsyncWithHttpInfo($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Ingredient';
        $request = $this->ingredientsIngredientIdGetRequest($ingredient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientsIngredientIdGet'
     *
     * @param  string $ingredient_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientsIngredientIdGetRequest($ingredient_id, string $contentType = self::contentTypes['ingredientsIngredientIdGet'][0])
    {

        // verify the required parameter 'ingredient_id' is set
        if ($ingredient_id === null || (is_array($ingredient_id) && count($ingredient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_id when calling ingredientsIngredientIdGet'
            );
        }


        $resourcePath = '/ingredients/{ingredientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($ingredient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ingredientId' . '}',
                ObjectSerializer::toPathValue($ingredient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientsIngredientIdPut
     *
     * Update an ingredient
     *
     * @param  string $ingredient_id ingredient_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIngredient $update_ingredient update_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ingredientsIngredientIdPut($ingredient_id, $update_ingredient, string $contentType = self::contentTypes['ingredientsIngredientIdPut'][0])
    {
        $this->ingredientsIngredientIdPutWithHttpInfo($ingredient_id, $update_ingredient, $contentType);
    }

    /**
     * Operation ingredientsIngredientIdPutWithHttpInfo
     *
     * Update an ingredient
     *
     * @param  string $ingredient_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIngredient $update_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientsIngredientIdPutWithHttpInfo($ingredient_id, $update_ingredient, string $contentType = self::contentTypes['ingredientsIngredientIdPut'][0])
    {
        $request = $this->ingredientsIngredientIdPutRequest($ingredient_id, $update_ingredient, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientsIngredientIdPutAsync
     *
     * Update an ingredient
     *
     * @param  string $ingredient_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIngredient $update_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsIngredientIdPutAsync($ingredient_id, $update_ingredient, string $contentType = self::contentTypes['ingredientsIngredientIdPut'][0])
    {
        return $this->ingredientsIngredientIdPutAsyncWithHttpInfo($ingredient_id, $update_ingredient, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientsIngredientIdPutAsyncWithHttpInfo
     *
     * Update an ingredient
     *
     * @param  string $ingredient_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIngredient $update_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsIngredientIdPutAsyncWithHttpInfo($ingredient_id, $update_ingredient, string $contentType = self::contentTypes['ingredientsIngredientIdPut'][0])
    {
        $returnType = '';
        $request = $this->ingredientsIngredientIdPutRequest($ingredient_id, $update_ingredient, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientsIngredientIdPut'
     *
     * @param  string $ingredient_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIngredient $update_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsIngredientIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientsIngredientIdPutRequest($ingredient_id, $update_ingredient, string $contentType = self::contentTypes['ingredientsIngredientIdPut'][0])
    {

        // verify the required parameter 'ingredient_id' is set
        if ($ingredient_id === null || (is_array($ingredient_id) && count($ingredient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_id when calling ingredientsIngredientIdPut'
            );
        }

        // verify the required parameter 'update_ingredient' is set
        if ($update_ingredient === null || (is_array($update_ingredient) && count($update_ingredient) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_ingredient when calling ingredientsIngredientIdPut'
            );
        }


        $resourcePath = '/ingredients/{ingredientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($ingredient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ingredientId' . '}',
                ObjectSerializer::toPathValue($ingredient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_ingredient)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_ingredient));
            } else {
                $httpBody = $update_ingredient;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientsPost
     *
     * Create a new ingredient
     *
     * @param  \OpenAPI\Client\Model\NewIngredient $new_ingredient new_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ingredientsPost($new_ingredient, string $contentType = self::contentTypes['ingredientsPost'][0])
    {
        $this->ingredientsPostWithHttpInfo($new_ingredient, $contentType);
    }

    /**
     * Operation ingredientsPostWithHttpInfo
     *
     * Create a new ingredient
     *
     * @param  \OpenAPI\Client\Model\NewIngredient $new_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientsPostWithHttpInfo($new_ingredient, string $contentType = self::contentTypes['ingredientsPost'][0])
    {
        $request = $this->ingredientsPostRequest($new_ingredient, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientsPostAsync
     *
     * Create a new ingredient
     *
     * @param  \OpenAPI\Client\Model\NewIngredient $new_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsPostAsync($new_ingredient, string $contentType = self::contentTypes['ingredientsPost'][0])
    {
        return $this->ingredientsPostAsyncWithHttpInfo($new_ingredient, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientsPostAsyncWithHttpInfo
     *
     * Create a new ingredient
     *
     * @param  \OpenAPI\Client\Model\NewIngredient $new_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsPostAsyncWithHttpInfo($new_ingredient, string $contentType = self::contentTypes['ingredientsPost'][0])
    {
        $returnType = '';
        $request = $this->ingredientsPostRequest($new_ingredient, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientsPost'
     *
     * @param  \OpenAPI\Client\Model\NewIngredient $new_ingredient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ingredientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientsPostRequest($new_ingredient, string $contentType = self::contentTypes['ingredientsPost'][0])
    {

        // verify the required parameter 'new_ingredient' is set
        if ($new_ingredient === null || (is_array($new_ingredient) && count($new_ingredient) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_ingredient when calling ingredientsPost'
            );
        }


        $resourcePath = '/ingredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_ingredient)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_ingredient));
            } else {
                $httpBody = $new_ingredient;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemCategoriesCategoryIdDelete
     *
     * Delete a menu item category
     *
     * @param  string $category_id category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemCategoriesCategoryIdDelete($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdDelete'][0])
    {
        $this->menuItemCategoriesCategoryIdDeleteWithHttpInfo($category_id, $contentType);
    }

    /**
     * Operation menuItemCategoriesCategoryIdDeleteWithHttpInfo
     *
     * Delete a menu item category
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemCategoriesCategoryIdDeleteWithHttpInfo($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdDelete'][0])
    {
        $request = $this->menuItemCategoriesCategoryIdDeleteRequest($category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemCategoriesCategoryIdDeleteAsync
     *
     * Delete a menu item category
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesCategoryIdDeleteAsync($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdDelete'][0])
    {
        return $this->menuItemCategoriesCategoryIdDeleteAsyncWithHttpInfo($category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemCategoriesCategoryIdDeleteAsyncWithHttpInfo
     *
     * Delete a menu item category
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesCategoryIdDeleteAsyncWithHttpInfo($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdDelete'][0])
    {
        $returnType = '';
        $request = $this->menuItemCategoriesCategoryIdDeleteRequest($category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemCategoriesCategoryIdDelete'
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemCategoriesCategoryIdDeleteRequest($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdDelete'][0])
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling menuItemCategoriesCategoryIdDelete'
            );
        }


        $resourcePath = '/menu-item-categories/{categoryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemCategoriesCategoryIdGet
     *
     * Get a menu item category by ID
     *
     * @param  string $category_id category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItemCategory
     */
    public function menuItemCategoriesCategoryIdGet($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdGet'][0])
    {
        list($response) = $this->menuItemCategoriesCategoryIdGetWithHttpInfo($category_id, $contentType);
        return $response;
    }

    /**
     * Operation menuItemCategoriesCategoryIdGetWithHttpInfo
     *
     * Get a menu item category by ID
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItemCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemCategoriesCategoryIdGetWithHttpInfo($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdGet'][0])
    {
        $request = $this->menuItemCategoriesCategoryIdGetRequest($category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItemCategory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItemCategory' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItemCategory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItemCategory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItemCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemCategoriesCategoryIdGetAsync
     *
     * Get a menu item category by ID
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesCategoryIdGetAsync($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdGet'][0])
    {
        return $this->menuItemCategoriesCategoryIdGetAsyncWithHttpInfo($category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemCategoriesCategoryIdGetAsyncWithHttpInfo
     *
     * Get a menu item category by ID
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesCategoryIdGetAsyncWithHttpInfo($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItemCategory';
        $request = $this->menuItemCategoriesCategoryIdGetRequest($category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemCategoriesCategoryIdGet'
     *
     * @param  string $category_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemCategoriesCategoryIdGetRequest($category_id, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdGet'][0])
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling menuItemCategoriesCategoryIdGet'
            );
        }


        $resourcePath = '/menu-item-categories/{categoryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemCategoriesCategoryIdPut
     *
     * Update a menu item category
     *
     * @param  string $category_id category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemCategory $update_menu_item_category update_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemCategoriesCategoryIdPut($category_id, $update_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdPut'][0])
    {
        $this->menuItemCategoriesCategoryIdPutWithHttpInfo($category_id, $update_menu_item_category, $contentType);
    }

    /**
     * Operation menuItemCategoriesCategoryIdPutWithHttpInfo
     *
     * Update a menu item category
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemCategory $update_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemCategoriesCategoryIdPutWithHttpInfo($category_id, $update_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdPut'][0])
    {
        $request = $this->menuItemCategoriesCategoryIdPutRequest($category_id, $update_menu_item_category, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemCategoriesCategoryIdPutAsync
     *
     * Update a menu item category
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemCategory $update_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesCategoryIdPutAsync($category_id, $update_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdPut'][0])
    {
        return $this->menuItemCategoriesCategoryIdPutAsyncWithHttpInfo($category_id, $update_menu_item_category, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemCategoriesCategoryIdPutAsyncWithHttpInfo
     *
     * Update a menu item category
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemCategory $update_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesCategoryIdPutAsyncWithHttpInfo($category_id, $update_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdPut'][0])
    {
        $returnType = '';
        $request = $this->menuItemCategoriesCategoryIdPutRequest($category_id, $update_menu_item_category, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemCategoriesCategoryIdPut'
     *
     * @param  string $category_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemCategory $update_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesCategoryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemCategoriesCategoryIdPutRequest($category_id, $update_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesCategoryIdPut'][0])
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling menuItemCategoriesCategoryIdPut'
            );
        }

        // verify the required parameter 'update_menu_item_category' is set
        if ($update_menu_item_category === null || (is_array($update_menu_item_category) && count($update_menu_item_category) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_menu_item_category when calling menuItemCategoriesCategoryIdPut'
            );
        }


        $resourcePath = '/menu-item-categories/{categoryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_menu_item_category)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_menu_item_category));
            } else {
                $httpBody = $update_menu_item_category;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemCategoriesGet
     *
     * Get all menu item categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItemCategory[]
     */
    public function menuItemCategoriesGet(string $contentType = self::contentTypes['menuItemCategoriesGet'][0])
    {
        list($response) = $this->menuItemCategoriesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation menuItemCategoriesGetWithHttpInfo
     *
     * Get all menu item categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItemCategory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemCategoriesGetWithHttpInfo(string $contentType = self::contentTypes['menuItemCategoriesGet'][0])
    {
        $request = $this->menuItemCategoriesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItemCategory[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItemCategory[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItemCategory[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItemCategory[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItemCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemCategoriesGetAsync
     *
     * Get all menu item categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesGetAsync(string $contentType = self::contentTypes['menuItemCategoriesGet'][0])
    {
        return $this->menuItemCategoriesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemCategoriesGetAsyncWithHttpInfo
     *
     * Get all menu item categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['menuItemCategoriesGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItemCategory[]';
        $request = $this->menuItemCategoriesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemCategoriesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemCategoriesGetRequest(string $contentType = self::contentTypes['menuItemCategoriesGet'][0])
    {


        $resourcePath = '/menu-item-categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemCategoriesPost
     *
     * Create a new menu item category
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemCategory $new_menu_item_category new_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemCategoriesPost($new_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesPost'][0])
    {
        $this->menuItemCategoriesPostWithHttpInfo($new_menu_item_category, $contentType);
    }

    /**
     * Operation menuItemCategoriesPostWithHttpInfo
     *
     * Create a new menu item category
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemCategory $new_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemCategoriesPostWithHttpInfo($new_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesPost'][0])
    {
        $request = $this->menuItemCategoriesPostRequest($new_menu_item_category, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemCategoriesPostAsync
     *
     * Create a new menu item category
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemCategory $new_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesPostAsync($new_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesPost'][0])
    {
        return $this->menuItemCategoriesPostAsyncWithHttpInfo($new_menu_item_category, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemCategoriesPostAsyncWithHttpInfo
     *
     * Create a new menu item category
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemCategory $new_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemCategoriesPostAsyncWithHttpInfo($new_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesPost'][0])
    {
        $returnType = '';
        $request = $this->menuItemCategoriesPostRequest($new_menu_item_category, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemCategoriesPost'
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemCategory $new_menu_item_category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemCategoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemCategoriesPostRequest($new_menu_item_category, string $contentType = self::contentTypes['menuItemCategoriesPost'][0])
    {

        // verify the required parameter 'new_menu_item_category' is set
        if ($new_menu_item_category === null || (is_array($new_menu_item_category) && count($new_menu_item_category) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_menu_item_category when calling menuItemCategoriesPost'
            );
        }


        $resourcePath = '/menu-item-categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_menu_item_category)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_menu_item_category));
            } else {
                $httpBody = $new_menu_item_category;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemOptionsGet
     *
     * Get all menu item options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItemOption[]
     */
    public function menuItemOptionsGet(string $contentType = self::contentTypes['menuItemOptionsGet'][0])
    {
        list($response) = $this->menuItemOptionsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation menuItemOptionsGetWithHttpInfo
     *
     * Get all menu item options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItemOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemOptionsGetWithHttpInfo(string $contentType = self::contentTypes['menuItemOptionsGet'][0])
    {
        $request = $this->menuItemOptionsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItemOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItemOption[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItemOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItemOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItemOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemOptionsGetAsync
     *
     * Get all menu item options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsGetAsync(string $contentType = self::contentTypes['menuItemOptionsGet'][0])
    {
        return $this->menuItemOptionsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemOptionsGetAsyncWithHttpInfo
     *
     * Get all menu item options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['menuItemOptionsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItemOption[]';
        $request = $this->menuItemOptionsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemOptionsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemOptionsGetRequest(string $contentType = self::contentTypes['menuItemOptionsGet'][0])
    {


        $resourcePath = '/menu-item-options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemOptionsOptionIdDelete
     *
     * Delete a menu item option
     *
     * @param  string $option_id option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemOptionsOptionIdDelete($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdDelete'][0])
    {
        $this->menuItemOptionsOptionIdDeleteWithHttpInfo($option_id, $contentType);
    }

    /**
     * Operation menuItemOptionsOptionIdDeleteWithHttpInfo
     *
     * Delete a menu item option
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemOptionsOptionIdDeleteWithHttpInfo($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdDelete'][0])
    {
        $request = $this->menuItemOptionsOptionIdDeleteRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemOptionsOptionIdDeleteAsync
     *
     * Delete a menu item option
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsOptionIdDeleteAsync($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdDelete'][0])
    {
        return $this->menuItemOptionsOptionIdDeleteAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemOptionsOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete a menu item option
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsOptionIdDeleteAsyncWithHttpInfo($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdDelete'][0])
    {
        $returnType = '';
        $request = $this->menuItemOptionsOptionIdDeleteRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemOptionsOptionIdDelete'
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemOptionsOptionIdDeleteRequest($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdDelete'][0])
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling menuItemOptionsOptionIdDelete'
            );
        }


        $resourcePath = '/menu-item-options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemOptionsOptionIdGet
     *
     * Get a menu item option by ID
     *
     * @param  string $option_id option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItemOption
     */
    public function menuItemOptionsOptionIdGet($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdGet'][0])
    {
        list($response) = $this->menuItemOptionsOptionIdGetWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation menuItemOptionsOptionIdGetWithHttpInfo
     *
     * Get a menu item option by ID
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItemOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemOptionsOptionIdGetWithHttpInfo($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdGet'][0])
    {
        $request = $this->menuItemOptionsOptionIdGetRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItemOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItemOption' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItemOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItemOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItemOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemOptionsOptionIdGetAsync
     *
     * Get a menu item option by ID
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsOptionIdGetAsync($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdGet'][0])
    {
        return $this->menuItemOptionsOptionIdGetAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemOptionsOptionIdGetAsyncWithHttpInfo
     *
     * Get a menu item option by ID
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsOptionIdGetAsyncWithHttpInfo($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItemOption';
        $request = $this->menuItemOptionsOptionIdGetRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemOptionsOptionIdGet'
     *
     * @param  string $option_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemOptionsOptionIdGetRequest($option_id, string $contentType = self::contentTypes['menuItemOptionsOptionIdGet'][0])
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling menuItemOptionsOptionIdGet'
            );
        }


        $resourcePath = '/menu-item-options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemOptionsOptionIdPut
     *
     * Update a menu item option
     *
     * @param  string $option_id option_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemOption $update_menu_item_option update_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemOptionsOptionIdPut($option_id, $update_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsOptionIdPut'][0])
    {
        $this->menuItemOptionsOptionIdPutWithHttpInfo($option_id, $update_menu_item_option, $contentType);
    }

    /**
     * Operation menuItemOptionsOptionIdPutWithHttpInfo
     *
     * Update a menu item option
     *
     * @param  string $option_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemOption $update_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemOptionsOptionIdPutWithHttpInfo($option_id, $update_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsOptionIdPut'][0])
    {
        $request = $this->menuItemOptionsOptionIdPutRequest($option_id, $update_menu_item_option, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemOptionsOptionIdPutAsync
     *
     * Update a menu item option
     *
     * @param  string $option_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemOption $update_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsOptionIdPutAsync($option_id, $update_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsOptionIdPut'][0])
    {
        return $this->menuItemOptionsOptionIdPutAsyncWithHttpInfo($option_id, $update_menu_item_option, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemOptionsOptionIdPutAsyncWithHttpInfo
     *
     * Update a menu item option
     *
     * @param  string $option_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemOption $update_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsOptionIdPutAsyncWithHttpInfo($option_id, $update_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsOptionIdPut'][0])
    {
        $returnType = '';
        $request = $this->menuItemOptionsOptionIdPutRequest($option_id, $update_menu_item_option, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemOptionsOptionIdPut'
     *
     * @param  string $option_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItemOption $update_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemOptionsOptionIdPutRequest($option_id, $update_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsOptionIdPut'][0])
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling menuItemOptionsOptionIdPut'
            );
        }

        // verify the required parameter 'update_menu_item_option' is set
        if ($update_menu_item_option === null || (is_array($update_menu_item_option) && count($update_menu_item_option) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_menu_item_option when calling menuItemOptionsOptionIdPut'
            );
        }


        $resourcePath = '/menu-item-options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_menu_item_option)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_menu_item_option));
            } else {
                $httpBody = $update_menu_item_option;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemOptionsPost
     *
     * Create a new menu item option
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemOption $new_menu_item_option new_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemOptionsPost($new_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsPost'][0])
    {
        $this->menuItemOptionsPostWithHttpInfo($new_menu_item_option, $contentType);
    }

    /**
     * Operation menuItemOptionsPostWithHttpInfo
     *
     * Create a new menu item option
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemOption $new_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemOptionsPostWithHttpInfo($new_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsPost'][0])
    {
        $request = $this->menuItemOptionsPostRequest($new_menu_item_option, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemOptionsPostAsync
     *
     * Create a new menu item option
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemOption $new_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsPostAsync($new_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsPost'][0])
    {
        return $this->menuItemOptionsPostAsyncWithHttpInfo($new_menu_item_option, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemOptionsPostAsyncWithHttpInfo
     *
     * Create a new menu item option
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemOption $new_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemOptionsPostAsyncWithHttpInfo($new_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsPost'][0])
    {
        $returnType = '';
        $request = $this->menuItemOptionsPostRequest($new_menu_item_option, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemOptionsPost'
     *
     * @param  \OpenAPI\Client\Model\NewMenuItemOption $new_menu_item_option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemOptionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemOptionsPostRequest($new_menu_item_option, string $contentType = self::contentTypes['menuItemOptionsPost'][0])
    {

        // verify the required parameter 'new_menu_item_option' is set
        if ($new_menu_item_option === null || (is_array($new_menu_item_option) && count($new_menu_item_option) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_menu_item_option when calling menuItemOptionsPost'
            );
        }


        $resourcePath = '/menu-item-options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_menu_item_option)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_menu_item_option));
            } else {
                $httpBody = $new_menu_item_option;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemsGet
     *
     * Get all menu items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItem[]
     */
    public function menuItemsGet(string $contentType = self::contentTypes['menuItemsGet'][0])
    {
        list($response) = $this->menuItemsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation menuItemsGetWithHttpInfo
     *
     * Get all menu items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemsGetWithHttpInfo(string $contentType = self::contentTypes['menuItemsGet'][0])
    {
        $request = $this->menuItemsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItem[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItem[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItem[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItem[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemsGetAsync
     *
     * Get all menu items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsGetAsync(string $contentType = self::contentTypes['menuItemsGet'][0])
    {
        return $this->menuItemsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemsGetAsyncWithHttpInfo
     *
     * Get all menu items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['menuItemsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItem[]';
        $request = $this->menuItemsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemsGetRequest(string $contentType = self::contentTypes['menuItemsGet'][0])
    {


        $resourcePath = '/menu-items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemsItemIdDelete
     *
     * Delete a menu item
     *
     * @param  string $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemsItemIdDelete($item_id, string $contentType = self::contentTypes['menuItemsItemIdDelete'][0])
    {
        $this->menuItemsItemIdDeleteWithHttpInfo($item_id, $contentType);
    }

    /**
     * Operation menuItemsItemIdDeleteWithHttpInfo
     *
     * Delete a menu item
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemsItemIdDeleteWithHttpInfo($item_id, string $contentType = self::contentTypes['menuItemsItemIdDelete'][0])
    {
        $request = $this->menuItemsItemIdDeleteRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemsItemIdDeleteAsync
     *
     * Delete a menu item
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsItemIdDeleteAsync($item_id, string $contentType = self::contentTypes['menuItemsItemIdDelete'][0])
    {
        return $this->menuItemsItemIdDeleteAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemsItemIdDeleteAsyncWithHttpInfo
     *
     * Delete a menu item
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsItemIdDeleteAsyncWithHttpInfo($item_id, string $contentType = self::contentTypes['menuItemsItemIdDelete'][0])
    {
        $returnType = '';
        $request = $this->menuItemsItemIdDeleteRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemsItemIdDelete'
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemsItemIdDeleteRequest($item_id, string $contentType = self::contentTypes['menuItemsItemIdDelete'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling menuItemsItemIdDelete'
            );
        }


        $resourcePath = '/menu-items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemsItemIdGet
     *
     * Get a menu item by ID
     *
     * @param  string $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItem
     */
    public function menuItemsItemIdGet($item_id, string $contentType = self::contentTypes['menuItemsItemIdGet'][0])
    {
        list($response) = $this->menuItemsItemIdGetWithHttpInfo($item_id, $contentType);
        return $response;
    }

    /**
     * Operation menuItemsItemIdGetWithHttpInfo
     *
     * Get a menu item by ID
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemsItemIdGetWithHttpInfo($item_id, string $contentType = self::contentTypes['menuItemsItemIdGet'][0])
    {
        $request = $this->menuItemsItemIdGetRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItem' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItem' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItem';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemsItemIdGetAsync
     *
     * Get a menu item by ID
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsItemIdGetAsync($item_id, string $contentType = self::contentTypes['menuItemsItemIdGet'][0])
    {
        return $this->menuItemsItemIdGetAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemsItemIdGetAsyncWithHttpInfo
     *
     * Get a menu item by ID
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsItemIdGetAsyncWithHttpInfo($item_id, string $contentType = self::contentTypes['menuItemsItemIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItem';
        $request = $this->menuItemsItemIdGetRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemsItemIdGet'
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemsItemIdGetRequest($item_id, string $contentType = self::contentTypes['menuItemsItemIdGet'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling menuItemsItemIdGet'
            );
        }


        $resourcePath = '/menu-items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemsItemIdPut
     *
     * Update a menu item
     *
     * @param  string $item_id item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItem $update_menu_item update_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemsItemIdPut($item_id, $update_menu_item, string $contentType = self::contentTypes['menuItemsItemIdPut'][0])
    {
        $this->menuItemsItemIdPutWithHttpInfo($item_id, $update_menu_item, $contentType);
    }

    /**
     * Operation menuItemsItemIdPutWithHttpInfo
     *
     * Update a menu item
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItem $update_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemsItemIdPutWithHttpInfo($item_id, $update_menu_item, string $contentType = self::contentTypes['menuItemsItemIdPut'][0])
    {
        $request = $this->menuItemsItemIdPutRequest($item_id, $update_menu_item, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemsItemIdPutAsync
     *
     * Update a menu item
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItem $update_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsItemIdPutAsync($item_id, $update_menu_item, string $contentType = self::contentTypes['menuItemsItemIdPut'][0])
    {
        return $this->menuItemsItemIdPutAsyncWithHttpInfo($item_id, $update_menu_item, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemsItemIdPutAsyncWithHttpInfo
     *
     * Update a menu item
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItem $update_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsItemIdPutAsyncWithHttpInfo($item_id, $update_menu_item, string $contentType = self::contentTypes['menuItemsItemIdPut'][0])
    {
        $returnType = '';
        $request = $this->menuItemsItemIdPutRequest($item_id, $update_menu_item, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemsItemIdPut'
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMenuItem $update_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemsItemIdPutRequest($item_id, $update_menu_item, string $contentType = self::contentTypes['menuItemsItemIdPut'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling menuItemsItemIdPut'
            );
        }

        // verify the required parameter 'update_menu_item' is set
        if ($update_menu_item === null || (is_array($update_menu_item) && count($update_menu_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_menu_item when calling menuItemsItemIdPut'
            );
        }


        $resourcePath = '/menu-items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_menu_item)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_menu_item));
            } else {
                $httpBody = $update_menu_item;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemsPost
     *
     * Create a new menu item
     *
     * @param  \OpenAPI\Client\Model\NewMenuItem $new_menu_item new_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menuItemsPost($new_menu_item, string $contentType = self::contentTypes['menuItemsPost'][0])
    {
        $this->menuItemsPostWithHttpInfo($new_menu_item, $contentType);
    }

    /**
     * Operation menuItemsPostWithHttpInfo
     *
     * Create a new menu item
     *
     * @param  \OpenAPI\Client\Model\NewMenuItem $new_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemsPostWithHttpInfo($new_menu_item, string $contentType = self::contentTypes['menuItemsPost'][0])
    {
        $request = $this->menuItemsPostRequest($new_menu_item, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemsPostAsync
     *
     * Create a new menu item
     *
     * @param  \OpenAPI\Client\Model\NewMenuItem $new_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsPostAsync($new_menu_item, string $contentType = self::contentTypes['menuItemsPost'][0])
    {
        return $this->menuItemsPostAsyncWithHttpInfo($new_menu_item, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemsPostAsyncWithHttpInfo
     *
     * Create a new menu item
     *
     * @param  \OpenAPI\Client\Model\NewMenuItem $new_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemsPostAsyncWithHttpInfo($new_menu_item, string $contentType = self::contentTypes['menuItemsPost'][0])
    {
        $returnType = '';
        $request = $this->menuItemsPostRequest($new_menu_item, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemsPost'
     *
     * @param  \OpenAPI\Client\Model\NewMenuItem $new_menu_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemsPostRequest($new_menu_item, string $contentType = self::contentTypes['menuItemsPost'][0])
    {

        // verify the required parameter 'new_menu_item' is set
        if ($new_menu_item === null || (is_array($new_menu_item) && count($new_menu_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_menu_item when calling menuItemsPost'
            );
        }


        $resourcePath = '/menu-items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_menu_item)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_menu_item));
            } else {
                $httpBody = $new_menu_item;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderItemsGet
     *
     * Get all order items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItem[]
     */
    public function orderItemsGet(string $contentType = self::contentTypes['orderItemsGet'][0])
    {
        list($response) = $this->orderItemsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation orderItemsGetWithHttpInfo
     *
     * Get all order items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function orderItemsGetWithHttpInfo(string $contentType = self::contentTypes['orderItemsGet'][0])
    {
        $request = $this->orderItemsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItem[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderItem[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItem[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItem[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderItemsGetAsync
     *
     * Get all order items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsGetAsync(string $contentType = self::contentTypes['orderItemsGet'][0])
    {
        return $this->orderItemsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderItemsGetAsyncWithHttpInfo
     *
     * Get all order items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['orderItemsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderItem[]';
        $request = $this->orderItemsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderItemsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function orderItemsGetRequest(string $contentType = self::contentTypes['orderItemsGet'][0])
    {


        $resourcePath = '/order-items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderItemsItemIdDelete
     *
     * Delete an order item
     *
     * @param  string $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orderItemsItemIdDelete($item_id, string $contentType = self::contentTypes['orderItemsItemIdDelete'][0])
    {
        $this->orderItemsItemIdDeleteWithHttpInfo($item_id, $contentType);
    }

    /**
     * Operation orderItemsItemIdDeleteWithHttpInfo
     *
     * Delete an order item
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderItemsItemIdDeleteWithHttpInfo($item_id, string $contentType = self::contentTypes['orderItemsItemIdDelete'][0])
    {
        $request = $this->orderItemsItemIdDeleteRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation orderItemsItemIdDeleteAsync
     *
     * Delete an order item
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsItemIdDeleteAsync($item_id, string $contentType = self::contentTypes['orderItemsItemIdDelete'][0])
    {
        return $this->orderItemsItemIdDeleteAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderItemsItemIdDeleteAsyncWithHttpInfo
     *
     * Delete an order item
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsItemIdDeleteAsyncWithHttpInfo($item_id, string $contentType = self::contentTypes['orderItemsItemIdDelete'][0])
    {
        $returnType = '';
        $request = $this->orderItemsItemIdDeleteRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderItemsItemIdDelete'
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function orderItemsItemIdDeleteRequest($item_id, string $contentType = self::contentTypes['orderItemsItemIdDelete'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling orderItemsItemIdDelete'
            );
        }


        $resourcePath = '/order-items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderItemsItemIdGet
     *
     * Get an order item by ID
     *
     * @param  string $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderItem
     */
    public function orderItemsItemIdGet($item_id, string $contentType = self::contentTypes['orderItemsItemIdGet'][0])
    {
        list($response) = $this->orderItemsItemIdGetWithHttpInfo($item_id, $contentType);
        return $response;
    }

    /**
     * Operation orderItemsItemIdGetWithHttpInfo
     *
     * Get an order item by ID
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderItemsItemIdGetWithHttpInfo($item_id, string $contentType = self::contentTypes['orderItemsItemIdGet'][0])
    {
        $request = $this->orderItemsItemIdGetRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderItem' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderItem' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderItem';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderItemsItemIdGetAsync
     *
     * Get an order item by ID
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsItemIdGetAsync($item_id, string $contentType = self::contentTypes['orderItemsItemIdGet'][0])
    {
        return $this->orderItemsItemIdGetAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderItemsItemIdGetAsyncWithHttpInfo
     *
     * Get an order item by ID
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsItemIdGetAsyncWithHttpInfo($item_id, string $contentType = self::contentTypes['orderItemsItemIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderItem';
        $request = $this->orderItemsItemIdGetRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderItemsItemIdGet'
     *
     * @param  string $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function orderItemsItemIdGetRequest($item_id, string $contentType = self::contentTypes['orderItemsItemIdGet'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling orderItemsItemIdGet'
            );
        }


        $resourcePath = '/order-items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderItemsItemIdPut
     *
     * Update an order item
     *
     * @param  string $item_id item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrderItem $update_order_item update_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orderItemsItemIdPut($item_id, $update_order_item, string $contentType = self::contentTypes['orderItemsItemIdPut'][0])
    {
        $this->orderItemsItemIdPutWithHttpInfo($item_id, $update_order_item, $contentType);
    }

    /**
     * Operation orderItemsItemIdPutWithHttpInfo
     *
     * Update an order item
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrderItem $update_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderItemsItemIdPutWithHttpInfo($item_id, $update_order_item, string $contentType = self::contentTypes['orderItemsItemIdPut'][0])
    {
        $request = $this->orderItemsItemIdPutRequest($item_id, $update_order_item, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation orderItemsItemIdPutAsync
     *
     * Update an order item
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrderItem $update_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsItemIdPutAsync($item_id, $update_order_item, string $contentType = self::contentTypes['orderItemsItemIdPut'][0])
    {
        return $this->orderItemsItemIdPutAsyncWithHttpInfo($item_id, $update_order_item, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderItemsItemIdPutAsyncWithHttpInfo
     *
     * Update an order item
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrderItem $update_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsItemIdPutAsyncWithHttpInfo($item_id, $update_order_item, string $contentType = self::contentTypes['orderItemsItemIdPut'][0])
    {
        $returnType = '';
        $request = $this->orderItemsItemIdPutRequest($item_id, $update_order_item, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderItemsItemIdPut'
     *
     * @param  string $item_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrderItem $update_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function orderItemsItemIdPutRequest($item_id, $update_order_item, string $contentType = self::contentTypes['orderItemsItemIdPut'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling orderItemsItemIdPut'
            );
        }

        // verify the required parameter 'update_order_item' is set
        if ($update_order_item === null || (is_array($update_order_item) && count($update_order_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_order_item when calling orderItemsItemIdPut'
            );
        }


        $resourcePath = '/order-items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_order_item)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_order_item));
            } else {
                $httpBody = $update_order_item;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderItemsPost
     *
     * Create a new order item
     *
     * @param  \OpenAPI\Client\Model\NewOrderItem $new_order_item new_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orderItemsPost($new_order_item, string $contentType = self::contentTypes['orderItemsPost'][0])
    {
        $this->orderItemsPostWithHttpInfo($new_order_item, $contentType);
    }

    /**
     * Operation orderItemsPostWithHttpInfo
     *
     * Create a new order item
     *
     * @param  \OpenAPI\Client\Model\NewOrderItem $new_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderItemsPostWithHttpInfo($new_order_item, string $contentType = self::contentTypes['orderItemsPost'][0])
    {
        $request = $this->orderItemsPostRequest($new_order_item, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation orderItemsPostAsync
     *
     * Create a new order item
     *
     * @param  \OpenAPI\Client\Model\NewOrderItem $new_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsPostAsync($new_order_item, string $contentType = self::contentTypes['orderItemsPost'][0])
    {
        return $this->orderItemsPostAsyncWithHttpInfo($new_order_item, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderItemsPostAsyncWithHttpInfo
     *
     * Create a new order item
     *
     * @param  \OpenAPI\Client\Model\NewOrderItem $new_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderItemsPostAsyncWithHttpInfo($new_order_item, string $contentType = self::contentTypes['orderItemsPost'][0])
    {
        $returnType = '';
        $request = $this->orderItemsPostRequest($new_order_item, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderItemsPost'
     *
     * @param  \OpenAPI\Client\Model\NewOrderItem $new_order_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['orderItemsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function orderItemsPostRequest($new_order_item, string $contentType = self::contentTypes['orderItemsPost'][0])
    {

        // verify the required parameter 'new_order_item' is set
        if ($new_order_item === null || (is_array($new_order_item) && count($new_order_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_order_item when calling orderItemsPost'
            );
        }


        $resourcePath = '/order-items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_order_item)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_order_item));
            } else {
                $httpBody = $new_order_item;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersGet
     *
     * Get all orders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order[]
     */
    public function ordersGet(string $contentType = self::contentTypes['ordersGet'][0])
    {
        list($response) = $this->ordersGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation ordersGetWithHttpInfo
     *
     * Get all orders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersGetWithHttpInfo(string $contentType = self::contentTypes['ordersGet'][0])
    {
        $request = $this->ordersGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Order[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersGetAsync
     *
     * Get all orders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersGetAsync(string $contentType = self::contentTypes['ordersGet'][0])
    {
        return $this->ordersGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersGetAsyncWithHttpInfo
     *
     * Get all orders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersGetAsyncWithHttpInfo(string $contentType = self::contentTypes['ordersGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Order[]';
        $request = $this->ordersGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ordersGetRequest(string $contentType = self::contentTypes['ordersGet'][0])
    {


        $resourcePath = '/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdDelete
     *
     * Delete an order
     *
     * @param  string $order_id order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ordersOrderIdDelete($order_id, string $contentType = self::contentTypes['ordersOrderIdDelete'][0])
    {
        $this->ordersOrderIdDeleteWithHttpInfo($order_id, $contentType);
    }

    /**
     * Operation ordersOrderIdDeleteWithHttpInfo
     *
     * Delete an order
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdDeleteWithHttpInfo($order_id, string $contentType = self::contentTypes['ordersOrderIdDelete'][0])
    {
        $request = $this->ordersOrderIdDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdDeleteAsync
     *
     * Delete an order
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdDeleteAsync($order_id, string $contentType = self::contentTypes['ordersOrderIdDelete'][0])
    {
        return $this->ordersOrderIdDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete an order
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdDeleteAsyncWithHttpInfo($order_id, string $contentType = self::contentTypes['ordersOrderIdDelete'][0])
    {
        $returnType = '';
        $request = $this->ordersOrderIdDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdDelete'
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ordersOrderIdDeleteRequest($order_id, string $contentType = self::contentTypes['ordersOrderIdDelete'][0])
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdDelete'
            );
        }


        $resourcePath = '/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdGet
     *
     * Get an order by ID
     *
     * @param  string $order_id order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function ordersOrderIdGet($order_id, string $contentType = self::contentTypes['ordersOrderIdGet'][0])
    {
        list($response) = $this->ordersOrderIdGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation ordersOrderIdGetWithHttpInfo
     *
     * Get an order by ID
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdGetWithHttpInfo($order_id, string $contentType = self::contentTypes['ordersOrderIdGet'][0])
    {
        $request = $this->ordersOrderIdGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Order' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdGetAsync
     *
     * Get an order by ID
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdGetAsync($order_id, string $contentType = self::contentTypes['ordersOrderIdGet'][0])
    {
        return $this->ordersOrderIdGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdGetAsyncWithHttpInfo
     *
     * Get an order by ID
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdGetAsyncWithHttpInfo($order_id, string $contentType = self::contentTypes['ordersOrderIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->ordersOrderIdGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdGet'
     *
     * @param  string $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ordersOrderIdGetRequest($order_id, string $contentType = self::contentTypes['ordersOrderIdGet'][0])
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdGet'
            );
        }


        $resourcePath = '/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOrderIdPut
     *
     * Update an order
     *
     * @param  string $order_id order_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrder $update_order update_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ordersOrderIdPut($order_id, $update_order, string $contentType = self::contentTypes['ordersOrderIdPut'][0])
    {
        $this->ordersOrderIdPutWithHttpInfo($order_id, $update_order, $contentType);
    }

    /**
     * Operation ordersOrderIdPutWithHttpInfo
     *
     * Update an order
     *
     * @param  string $order_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrder $update_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOrderIdPutWithHttpInfo($order_id, $update_order, string $contentType = self::contentTypes['ordersOrderIdPut'][0])
    {
        $request = $this->ordersOrderIdPutRequest($order_id, $update_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOrderIdPutAsync
     *
     * Update an order
     *
     * @param  string $order_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrder $update_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdPutAsync($order_id, $update_order, string $contentType = self::contentTypes['ordersOrderIdPut'][0])
    {
        return $this->ordersOrderIdPutAsyncWithHttpInfo($order_id, $update_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOrderIdPutAsyncWithHttpInfo
     *
     * Update an order
     *
     * @param  string $order_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrder $update_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOrderIdPutAsyncWithHttpInfo($order_id, $update_order, string $contentType = self::contentTypes['ordersOrderIdPut'][0])
    {
        $returnType = '';
        $request = $this->ordersOrderIdPutRequest($order_id, $update_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOrderIdPut'
     *
     * @param  string $order_id (required)
     * @param  \OpenAPI\Client\Model\UpdateOrder $update_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ordersOrderIdPutRequest($order_id, $update_order, string $contentType = self::contentTypes['ordersOrderIdPut'][0])
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling ordersOrderIdPut'
            );
        }

        // verify the required parameter 'update_order' is set
        if ($update_order === null || (is_array($update_order) && count($update_order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_order when calling ordersOrderIdPut'
            );
        }


        $resourcePath = '/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_order)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_order));
            } else {
                $httpBody = $update_order;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersPost
     *
     * Create a new order
     *
     * @param  \OpenAPI\Client\Model\NewOrder $new_order new_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ordersPost($new_order, string $contentType = self::contentTypes['ordersPost'][0])
    {
        $this->ordersPostWithHttpInfo($new_order, $contentType);
    }

    /**
     * Operation ordersPostWithHttpInfo
     *
     * Create a new order
     *
     * @param  \OpenAPI\Client\Model\NewOrder $new_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersPostWithHttpInfo($new_order, string $contentType = self::contentTypes['ordersPost'][0])
    {
        $request = $this->ordersPostRequest($new_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ordersPostAsync
     *
     * Create a new order
     *
     * @param  \OpenAPI\Client\Model\NewOrder $new_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersPostAsync($new_order, string $contentType = self::contentTypes['ordersPost'][0])
    {
        return $this->ordersPostAsyncWithHttpInfo($new_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersPostAsyncWithHttpInfo
     *
     * Create a new order
     *
     * @param  \OpenAPI\Client\Model\NewOrder $new_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersPostAsyncWithHttpInfo($new_order, string $contentType = self::contentTypes['ordersPost'][0])
    {
        $returnType = '';
        $request = $this->ordersPostRequest($new_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersPost'
     *
     * @param  \OpenAPI\Client\Model\NewOrder $new_order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ordersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ordersPostRequest($new_order, string $contentType = self::contentTypes['ordersPost'][0])
    {

        // verify the required parameter 'new_order' is set
        if ($new_order === null || (is_array($new_order) && count($new_order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_order when calling ordersPost'
            );
        }


        $resourcePath = '/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_order)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_order));
            } else {
                $httpBody = $new_order;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsComponentItemGet
     *
     * Generate a report for a specific component and item
     *
     * @param  string $component The component for which the report is being generated (e.g., &#39;restaurants&#39;, &#39;menus&#39;, &#39;orders&#39;) (required)
     * @param  string $item The specific item within the component for which the report is being generated (e.g., &#39;revenue&#39;, &#39;ratings&#39;, &#39;total&#39;) (required)
     * @param  \DateTime $start_date Start date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  \DateTime $end_date End date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  int $limit Limit the number of results (default: 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsComponentItemGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsComponentItemGet($component, $item, $start_date = null, $end_date = null, $limit = 100, string $contentType = self::contentTypes['reportsComponentItemGet'][0])
    {
        $this->reportsComponentItemGetWithHttpInfo($component, $item, $start_date, $end_date, $limit, $contentType);
    }

    /**
     * Operation reportsComponentItemGetWithHttpInfo
     *
     * Generate a report for a specific component and item
     *
     * @param  string $component The component for which the report is being generated (e.g., &#39;restaurants&#39;, &#39;menus&#39;, &#39;orders&#39;) (required)
     * @param  string $item The specific item within the component for which the report is being generated (e.g., &#39;revenue&#39;, &#39;ratings&#39;, &#39;total&#39;) (required)
     * @param  \DateTime $start_date Start date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  \DateTime $end_date End date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  int $limit Limit the number of results (default: 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsComponentItemGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsComponentItemGetWithHttpInfo($component, $item, $start_date = null, $end_date = null, $limit = 100, string $contentType = self::contentTypes['reportsComponentItemGet'][0])
    {
        $request = $this->reportsComponentItemGetRequest($component, $item, $start_date, $end_date, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsComponentItemGetAsync
     *
     * Generate a report for a specific component and item
     *
     * @param  string $component The component for which the report is being generated (e.g., &#39;restaurants&#39;, &#39;menus&#39;, &#39;orders&#39;) (required)
     * @param  string $item The specific item within the component for which the report is being generated (e.g., &#39;revenue&#39;, &#39;ratings&#39;, &#39;total&#39;) (required)
     * @param  \DateTime $start_date Start date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  \DateTime $end_date End date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  int $limit Limit the number of results (default: 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsComponentItemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsComponentItemGetAsync($component, $item, $start_date = null, $end_date = null, $limit = 100, string $contentType = self::contentTypes['reportsComponentItemGet'][0])
    {
        return $this->reportsComponentItemGetAsyncWithHttpInfo($component, $item, $start_date, $end_date, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsComponentItemGetAsyncWithHttpInfo
     *
     * Generate a report for a specific component and item
     *
     * @param  string $component The component for which the report is being generated (e.g., &#39;restaurants&#39;, &#39;menus&#39;, &#39;orders&#39;) (required)
     * @param  string $item The specific item within the component for which the report is being generated (e.g., &#39;revenue&#39;, &#39;ratings&#39;, &#39;total&#39;) (required)
     * @param  \DateTime $start_date Start date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  \DateTime $end_date End date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  int $limit Limit the number of results (default: 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsComponentItemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsComponentItemGetAsyncWithHttpInfo($component, $item, $start_date = null, $end_date = null, $limit = 100, string $contentType = self::contentTypes['reportsComponentItemGet'][0])
    {
        $returnType = '';
        $request = $this->reportsComponentItemGetRequest($component, $item, $start_date, $end_date, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsComponentItemGet'
     *
     * @param  string $component The component for which the report is being generated (e.g., &#39;restaurants&#39;, &#39;menus&#39;, &#39;orders&#39;) (required)
     * @param  string $item The specific item within the component for which the report is being generated (e.g., &#39;revenue&#39;, &#39;ratings&#39;, &#39;total&#39;) (required)
     * @param  \DateTime $start_date Start date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  \DateTime $end_date End date for the report (format: &#39;YYYY-MM-DD&#39;) (optional)
     * @param  int $limit Limit the number of results (default: 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsComponentItemGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsComponentItemGetRequest($component, $item, $start_date = null, $end_date = null, $limit = 100, string $contentType = self::contentTypes['reportsComponentItemGet'][0])
    {

        // verify the required parameter 'component' is set
        if ($component === null || (is_array($component) && count($component) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $component when calling reportsComponentItemGet'
            );
        }

        // verify the required parameter 'item' is set
        if ($item === null || (is_array($item) && count($item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item when calling reportsComponentItemGet'
            );
        }





        $resourcePath = '/reports/{component}/{item}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'end_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($component !== null) {
            $resourcePath = str_replace(
                '{' . 'component' . '}',
                ObjectSerializer::toPathValue($component),
                $resourcePath
            );
        }
        // path params
        if ($item !== null) {
            $resourcePath = str_replace(
                '{' . 'item' . '}',
                ObjectSerializer::toPathValue($item),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsCustomersAverageOrderFrequencyGet
     *
     * Generate a report of average order frequency per customer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersAverageOrderFrequencyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsCustomersAverageOrderFrequencyGet(string $contentType = self::contentTypes['reportsCustomersAverageOrderFrequencyGet'][0])
    {
        $this->reportsCustomersAverageOrderFrequencyGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsCustomersAverageOrderFrequencyGetWithHttpInfo
     *
     * Generate a report of average order frequency per customer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersAverageOrderFrequencyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsCustomersAverageOrderFrequencyGetWithHttpInfo(string $contentType = self::contentTypes['reportsCustomersAverageOrderFrequencyGet'][0])
    {
        $request = $this->reportsCustomersAverageOrderFrequencyGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsCustomersAverageOrderFrequencyGetAsync
     *
     * Generate a report of average order frequency per customer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersAverageOrderFrequencyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersAverageOrderFrequencyGetAsync(string $contentType = self::contentTypes['reportsCustomersAverageOrderFrequencyGet'][0])
    {
        return $this->reportsCustomersAverageOrderFrequencyGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsCustomersAverageOrderFrequencyGetAsyncWithHttpInfo
     *
     * Generate a report of average order frequency per customer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersAverageOrderFrequencyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersAverageOrderFrequencyGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsCustomersAverageOrderFrequencyGet'][0])
    {
        $returnType = '';
        $request = $this->reportsCustomersAverageOrderFrequencyGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsCustomersAverageOrderFrequencyGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersAverageOrderFrequencyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsCustomersAverageOrderFrequencyGetRequest(string $contentType = self::contentTypes['reportsCustomersAverageOrderFrequencyGet'][0])
    {


        $resourcePath = '/reports/customers/average-order-frequency';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsCustomersRetentionGet
     *
     * Generate a report of customer retention rate
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersRetentionGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsCustomersRetentionGet(string $contentType = self::contentTypes['reportsCustomersRetentionGet'][0])
    {
        $this->reportsCustomersRetentionGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsCustomersRetentionGetWithHttpInfo
     *
     * Generate a report of customer retention rate
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersRetentionGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsCustomersRetentionGetWithHttpInfo(string $contentType = self::contentTypes['reportsCustomersRetentionGet'][0])
    {
        $request = $this->reportsCustomersRetentionGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsCustomersRetentionGetAsync
     *
     * Generate a report of customer retention rate
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersRetentionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersRetentionGetAsync(string $contentType = self::contentTypes['reportsCustomersRetentionGet'][0])
    {
        return $this->reportsCustomersRetentionGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsCustomersRetentionGetAsyncWithHttpInfo
     *
     * Generate a report of customer retention rate
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersRetentionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersRetentionGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsCustomersRetentionGet'][0])
    {
        $returnType = '';
        $request = $this->reportsCustomersRetentionGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsCustomersRetentionGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersRetentionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsCustomersRetentionGetRequest(string $contentType = self::contentTypes['reportsCustomersRetentionGet'][0])
    {


        $resourcePath = '/reports/customers/retention';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsCustomersTotalGet
     *
     * Generate a report of total number of customers registered on the platform
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersTotalGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsCustomersTotalGet(string $contentType = self::contentTypes['reportsCustomersTotalGet'][0])
    {
        $this->reportsCustomersTotalGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsCustomersTotalGetWithHttpInfo
     *
     * Generate a report of total number of customers registered on the platform
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersTotalGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsCustomersTotalGetWithHttpInfo(string $contentType = self::contentTypes['reportsCustomersTotalGet'][0])
    {
        $request = $this->reportsCustomersTotalGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsCustomersTotalGetAsync
     *
     * Generate a report of total number of customers registered on the platform
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersTotalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersTotalGetAsync(string $contentType = self::contentTypes['reportsCustomersTotalGet'][0])
    {
        return $this->reportsCustomersTotalGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsCustomersTotalGetAsyncWithHttpInfo
     *
     * Generate a report of total number of customers registered on the platform
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersTotalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsCustomersTotalGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsCustomersTotalGet'][0])
    {
        $returnType = '';
        $request = $this->reportsCustomersTotalGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsCustomersTotalGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsCustomersTotalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsCustomersTotalGetRequest(string $contentType = self::contentTypes['reportsCustomersTotalGet'][0])
    {


        $resourcePath = '/reports/customers/total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsDiscountsEffectivenessGet
     *
     * Generate a report of effectiveness of discounts in increasing order volume or customer retention
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsEffectivenessGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsDiscountsEffectivenessGet(string $contentType = self::contentTypes['reportsDiscountsEffectivenessGet'][0])
    {
        $this->reportsDiscountsEffectivenessGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsDiscountsEffectivenessGetWithHttpInfo
     *
     * Generate a report of effectiveness of discounts in increasing order volume or customer retention
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsEffectivenessGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsDiscountsEffectivenessGetWithHttpInfo(string $contentType = self::contentTypes['reportsDiscountsEffectivenessGet'][0])
    {
        $request = $this->reportsDiscountsEffectivenessGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsDiscountsEffectivenessGetAsync
     *
     * Generate a report of effectiveness of discounts in increasing order volume or customer retention
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsEffectivenessGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsDiscountsEffectivenessGetAsync(string $contentType = self::contentTypes['reportsDiscountsEffectivenessGet'][0])
    {
        return $this->reportsDiscountsEffectivenessGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsDiscountsEffectivenessGetAsyncWithHttpInfo
     *
     * Generate a report of effectiveness of discounts in increasing order volume or customer retention
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsEffectivenessGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsDiscountsEffectivenessGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsDiscountsEffectivenessGet'][0])
    {
        $returnType = '';
        $request = $this->reportsDiscountsEffectivenessGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsDiscountsEffectivenessGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsEffectivenessGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsDiscountsEffectivenessGetRequest(string $contentType = self::contentTypes['reportsDiscountsEffectivenessGet'][0])
    {


        $resourcePath = '/reports/discounts/effectiveness';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsDiscountsRevenueImpactGet
     *
     * Generate a report of revenue impact of discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsRevenueImpactGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsDiscountsRevenueImpactGet(string $contentType = self::contentTypes['reportsDiscountsRevenueImpactGet'][0])
    {
        $this->reportsDiscountsRevenueImpactGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsDiscountsRevenueImpactGetWithHttpInfo
     *
     * Generate a report of revenue impact of discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsRevenueImpactGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsDiscountsRevenueImpactGetWithHttpInfo(string $contentType = self::contentTypes['reportsDiscountsRevenueImpactGet'][0])
    {
        $request = $this->reportsDiscountsRevenueImpactGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsDiscountsRevenueImpactGetAsync
     *
     * Generate a report of revenue impact of discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsRevenueImpactGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsDiscountsRevenueImpactGetAsync(string $contentType = self::contentTypes['reportsDiscountsRevenueImpactGet'][0])
    {
        return $this->reportsDiscountsRevenueImpactGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsDiscountsRevenueImpactGetAsyncWithHttpInfo
     *
     * Generate a report of revenue impact of discounts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsRevenueImpactGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsDiscountsRevenueImpactGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsDiscountsRevenueImpactGet'][0])
    {
        $returnType = '';
        $request = $this->reportsDiscountsRevenueImpactGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsDiscountsRevenueImpactGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsRevenueImpactGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsDiscountsRevenueImpactGetRequest(string $contentType = self::contentTypes['reportsDiscountsRevenueImpactGet'][0])
    {


        $resourcePath = '/reports/discounts/revenue-impact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsDiscountsUsageGet
     *
     * Generate a report of usage statistics for each discount code
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsUsageGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsDiscountsUsageGet(string $contentType = self::contentTypes['reportsDiscountsUsageGet'][0])
    {
        $this->reportsDiscountsUsageGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsDiscountsUsageGetWithHttpInfo
     *
     * Generate a report of usage statistics for each discount code
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsUsageGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsDiscountsUsageGetWithHttpInfo(string $contentType = self::contentTypes['reportsDiscountsUsageGet'][0])
    {
        $request = $this->reportsDiscountsUsageGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsDiscountsUsageGetAsync
     *
     * Generate a report of usage statistics for each discount code
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsUsageGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsDiscountsUsageGetAsync(string $contentType = self::contentTypes['reportsDiscountsUsageGet'][0])
    {
        return $this->reportsDiscountsUsageGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsDiscountsUsageGetAsyncWithHttpInfo
     *
     * Generate a report of usage statistics for each discount code
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsUsageGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsDiscountsUsageGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsDiscountsUsageGet'][0])
    {
        $returnType = '';
        $request = $this->reportsDiscountsUsageGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsDiscountsUsageGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsDiscountsUsageGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsDiscountsUsageGetRequest(string $contentType = self::contentTypes['reportsDiscountsUsageGet'][0])
    {


        $resourcePath = '/reports/discounts/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsGet
     *
     * Get all reports
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Report[]
     */
    public function reportsGet(string $contentType = self::contentTypes['reportsGet'][0])
    {
        list($response) = $this->reportsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation reportsGetWithHttpInfo
     *
     * Get all reports
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Report[], HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsGetWithHttpInfo(string $contentType = self::contentTypes['reportsGet'][0])
    {
        $request = $this->reportsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Report[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Report[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Report[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Report[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Report[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsGetAsync
     *
     * Get all reports
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsGetAsync(string $contentType = self::contentTypes['reportsGet'][0])
    {
        return $this->reportsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsGetAsyncWithHttpInfo
     *
     * Get all reports
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Report[]';
        $request = $this->reportsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsGetRequest(string $contentType = self::contentTypes['reportsGet'][0])
    {


        $resourcePath = '/reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsMenusPopularityGet
     *
     * Generate a report of most popular dishes at each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsMenusPopularityGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsMenusPopularityGet(string $contentType = self::contentTypes['reportsMenusPopularityGet'][0])
    {
        $this->reportsMenusPopularityGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsMenusPopularityGetWithHttpInfo
     *
     * Generate a report of most popular dishes at each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsMenusPopularityGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsMenusPopularityGetWithHttpInfo(string $contentType = self::contentTypes['reportsMenusPopularityGet'][0])
    {
        $request = $this->reportsMenusPopularityGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsMenusPopularityGetAsync
     *
     * Generate a report of most popular dishes at each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsMenusPopularityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsMenusPopularityGetAsync(string $contentType = self::contentTypes['reportsMenusPopularityGet'][0])
    {
        return $this->reportsMenusPopularityGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsMenusPopularityGetAsyncWithHttpInfo
     *
     * Generate a report of most popular dishes at each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsMenusPopularityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsMenusPopularityGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsMenusPopularityGet'][0])
    {
        $returnType = '';
        $request = $this->reportsMenusPopularityGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsMenusPopularityGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsMenusPopularityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsMenusPopularityGetRequest(string $contentType = self::contentTypes['reportsMenusPopularityGet'][0])
    {


        $resourcePath = '/reports/menus/popularity';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsOrdersAverageValueGet
     *
     * Generate a report of average order value within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersAverageValueGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsOrdersAverageValueGet(string $contentType = self::contentTypes['reportsOrdersAverageValueGet'][0])
    {
        $this->reportsOrdersAverageValueGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsOrdersAverageValueGetWithHttpInfo
     *
     * Generate a report of average order value within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersAverageValueGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsOrdersAverageValueGetWithHttpInfo(string $contentType = self::contentTypes['reportsOrdersAverageValueGet'][0])
    {
        $request = $this->reportsOrdersAverageValueGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsOrdersAverageValueGetAsync
     *
     * Generate a report of average order value within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersAverageValueGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersAverageValueGetAsync(string $contentType = self::contentTypes['reportsOrdersAverageValueGet'][0])
    {
        return $this->reportsOrdersAverageValueGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsOrdersAverageValueGetAsyncWithHttpInfo
     *
     * Generate a report of average order value within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersAverageValueGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersAverageValueGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsOrdersAverageValueGet'][0])
    {
        $returnType = '';
        $request = $this->reportsOrdersAverageValueGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsOrdersAverageValueGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersAverageValueGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsOrdersAverageValueGetRequest(string $contentType = self::contentTypes['reportsOrdersAverageValueGet'][0])
    {


        $resourcePath = '/reports/orders/average-value';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsOrdersFulfillmentTimeGet
     *
     * Generate a report of order fulfillment time statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersFulfillmentTimeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsOrdersFulfillmentTimeGet(string $contentType = self::contentTypes['reportsOrdersFulfillmentTimeGet'][0])
    {
        $this->reportsOrdersFulfillmentTimeGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsOrdersFulfillmentTimeGetWithHttpInfo
     *
     * Generate a report of order fulfillment time statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersFulfillmentTimeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsOrdersFulfillmentTimeGetWithHttpInfo(string $contentType = self::contentTypes['reportsOrdersFulfillmentTimeGet'][0])
    {
        $request = $this->reportsOrdersFulfillmentTimeGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsOrdersFulfillmentTimeGetAsync
     *
     * Generate a report of order fulfillment time statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersFulfillmentTimeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersFulfillmentTimeGetAsync(string $contentType = self::contentTypes['reportsOrdersFulfillmentTimeGet'][0])
    {
        return $this->reportsOrdersFulfillmentTimeGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsOrdersFulfillmentTimeGetAsyncWithHttpInfo
     *
     * Generate a report of order fulfillment time statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersFulfillmentTimeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersFulfillmentTimeGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsOrdersFulfillmentTimeGet'][0])
    {
        $returnType = '';
        $request = $this->reportsOrdersFulfillmentTimeGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsOrdersFulfillmentTimeGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersFulfillmentTimeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsOrdersFulfillmentTimeGetRequest(string $contentType = self::contentTypes['reportsOrdersFulfillmentTimeGet'][0])
    {


        $resourcePath = '/reports/orders/fulfillment-time';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsOrdersTotalGet
     *
     * Generate a report of total number of orders placed within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersTotalGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsOrdersTotalGet(string $contentType = self::contentTypes['reportsOrdersTotalGet'][0])
    {
        $this->reportsOrdersTotalGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsOrdersTotalGetWithHttpInfo
     *
     * Generate a report of total number of orders placed within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersTotalGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsOrdersTotalGetWithHttpInfo(string $contentType = self::contentTypes['reportsOrdersTotalGet'][0])
    {
        $request = $this->reportsOrdersTotalGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsOrdersTotalGetAsync
     *
     * Generate a report of total number of orders placed within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersTotalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersTotalGetAsync(string $contentType = self::contentTypes['reportsOrdersTotalGet'][0])
    {
        return $this->reportsOrdersTotalGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsOrdersTotalGetAsyncWithHttpInfo
     *
     * Generate a report of total number of orders placed within a specific time period
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersTotalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsOrdersTotalGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsOrdersTotalGet'][0])
    {
        $returnType = '';
        $request = $this->reportsOrdersTotalGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsOrdersTotalGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsOrdersTotalGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsOrdersTotalGetRequest(string $contentType = self::contentTypes['reportsOrdersTotalGet'][0])
    {


        $resourcePath = '/reports/orders/total';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsPost
     *
     * Create a new report
     *
     * @param  \OpenAPI\Client\Model\NewReport $new_report new_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsPost($new_report, string $contentType = self::contentTypes['reportsPost'][0])
    {
        $this->reportsPostWithHttpInfo($new_report, $contentType);
    }

    /**
     * Operation reportsPostWithHttpInfo
     *
     * Create a new report
     *
     * @param  \OpenAPI\Client\Model\NewReport $new_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsPostWithHttpInfo($new_report, string $contentType = self::contentTypes['reportsPost'][0])
    {
        $request = $this->reportsPostRequest($new_report, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsPostAsync
     *
     * Create a new report
     *
     * @param  \OpenAPI\Client\Model\NewReport $new_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsPostAsync($new_report, string $contentType = self::contentTypes['reportsPost'][0])
    {
        return $this->reportsPostAsyncWithHttpInfo($new_report, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsPostAsyncWithHttpInfo
     *
     * Create a new report
     *
     * @param  \OpenAPI\Client\Model\NewReport $new_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsPostAsyncWithHttpInfo($new_report, string $contentType = self::contentTypes['reportsPost'][0])
    {
        $returnType = '';
        $request = $this->reportsPostRequest($new_report, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsPost'
     *
     * @param  \OpenAPI\Client\Model\NewReport $new_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsPostRequest($new_report, string $contentType = self::contentTypes['reportsPost'][0])
    {

        // verify the required parameter 'new_report' is set
        if ($new_report === null || (is_array($new_report) && count($new_report) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_report when calling reportsPost'
            );
        }


        $resourcePath = '/reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_report)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_report));
            } else {
                $httpBody = $new_report;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsReportIdDelete
     *
     * Delete a report
     *
     * @param  string $report_id report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsReportIdDelete($report_id, string $contentType = self::contentTypes['reportsReportIdDelete'][0])
    {
        $this->reportsReportIdDeleteWithHttpInfo($report_id, $contentType);
    }

    /**
     * Operation reportsReportIdDeleteWithHttpInfo
     *
     * Delete a report
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsReportIdDeleteWithHttpInfo($report_id, string $contentType = self::contentTypes['reportsReportIdDelete'][0])
    {
        $request = $this->reportsReportIdDeleteRequest($report_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsReportIdDeleteAsync
     *
     * Delete a report
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReportIdDeleteAsync($report_id, string $contentType = self::contentTypes['reportsReportIdDelete'][0])
    {
        return $this->reportsReportIdDeleteAsyncWithHttpInfo($report_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsReportIdDeleteAsyncWithHttpInfo
     *
     * Delete a report
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReportIdDeleteAsyncWithHttpInfo($report_id, string $contentType = self::contentTypes['reportsReportIdDelete'][0])
    {
        $returnType = '';
        $request = $this->reportsReportIdDeleteRequest($report_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsReportIdDelete'
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsReportIdDeleteRequest($report_id, string $contentType = self::contentTypes['reportsReportIdDelete'][0])
    {

        // verify the required parameter 'report_id' is set
        if ($report_id === null || (is_array($report_id) && count($report_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $report_id when calling reportsReportIdDelete'
            );
        }


        $resourcePath = '/reports/{reportId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($report_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reportId' . '}',
                ObjectSerializer::toPathValue($report_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsReportIdGet
     *
     * Get a report by ID
     *
     * @param  string $report_id report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Report
     */
    public function reportsReportIdGet($report_id, string $contentType = self::contentTypes['reportsReportIdGet'][0])
    {
        list($response) = $this->reportsReportIdGetWithHttpInfo($report_id, $contentType);
        return $response;
    }

    /**
     * Operation reportsReportIdGetWithHttpInfo
     *
     * Get a report by ID
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Report, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsReportIdGetWithHttpInfo($report_id, string $contentType = self::contentTypes['reportsReportIdGet'][0])
    {
        $request = $this->reportsReportIdGetRequest($report_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Report' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Report' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Report', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Report';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Report',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportsReportIdGetAsync
     *
     * Get a report by ID
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReportIdGetAsync($report_id, string $contentType = self::contentTypes['reportsReportIdGet'][0])
    {
        return $this->reportsReportIdGetAsyncWithHttpInfo($report_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsReportIdGetAsyncWithHttpInfo
     *
     * Get a report by ID
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReportIdGetAsyncWithHttpInfo($report_id, string $contentType = self::contentTypes['reportsReportIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Report';
        $request = $this->reportsReportIdGetRequest($report_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsReportIdGet'
     *
     * @param  string $report_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsReportIdGetRequest($report_id, string $contentType = self::contentTypes['reportsReportIdGet'][0])
    {

        // verify the required parameter 'report_id' is set
        if ($report_id === null || (is_array($report_id) && count($report_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $report_id when calling reportsReportIdGet'
            );
        }


        $resourcePath = '/reports/{reportId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($report_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reportId' . '}',
                ObjectSerializer::toPathValue($report_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsReportIdPut
     *
     * Update a report
     *
     * @param  string $report_id report_id (required)
     * @param  \OpenAPI\Client\Model\UpdateReport $update_report update_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsReportIdPut($report_id, $update_report, string $contentType = self::contentTypes['reportsReportIdPut'][0])
    {
        $this->reportsReportIdPutWithHttpInfo($report_id, $update_report, $contentType);
    }

    /**
     * Operation reportsReportIdPutWithHttpInfo
     *
     * Update a report
     *
     * @param  string $report_id (required)
     * @param  \OpenAPI\Client\Model\UpdateReport $update_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsReportIdPutWithHttpInfo($report_id, $update_report, string $contentType = self::contentTypes['reportsReportIdPut'][0])
    {
        $request = $this->reportsReportIdPutRequest($report_id, $update_report, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsReportIdPutAsync
     *
     * Update a report
     *
     * @param  string $report_id (required)
     * @param  \OpenAPI\Client\Model\UpdateReport $update_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReportIdPutAsync($report_id, $update_report, string $contentType = self::contentTypes['reportsReportIdPut'][0])
    {
        return $this->reportsReportIdPutAsyncWithHttpInfo($report_id, $update_report, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsReportIdPutAsyncWithHttpInfo
     *
     * Update a report
     *
     * @param  string $report_id (required)
     * @param  \OpenAPI\Client\Model\UpdateReport $update_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsReportIdPutAsyncWithHttpInfo($report_id, $update_report, string $contentType = self::contentTypes['reportsReportIdPut'][0])
    {
        $returnType = '';
        $request = $this->reportsReportIdPutRequest($report_id, $update_report, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsReportIdPut'
     *
     * @param  string $report_id (required)
     * @param  \OpenAPI\Client\Model\UpdateReport $update_report (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsReportIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsReportIdPutRequest($report_id, $update_report, string $contentType = self::contentTypes['reportsReportIdPut'][0])
    {

        // verify the required parameter 'report_id' is set
        if ($report_id === null || (is_array($report_id) && count($report_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $report_id when calling reportsReportIdPut'
            );
        }

        // verify the required parameter 'update_report' is set
        if ($update_report === null || (is_array($update_report) && count($update_report) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_report when calling reportsReportIdPut'
            );
        }


        $resourcePath = '/reports/{reportId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($report_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reportId' . '}',
                ObjectSerializer::toPathValue($report_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_report)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_report));
            } else {
                $httpBody = $update_report;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsRestaurantsOrdersGet
     *
     * Generate a report of total orders received by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsOrdersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsRestaurantsOrdersGet(string $contentType = self::contentTypes['reportsRestaurantsOrdersGet'][0])
    {
        $this->reportsRestaurantsOrdersGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsRestaurantsOrdersGetWithHttpInfo
     *
     * Generate a report of total orders received by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsOrdersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsRestaurantsOrdersGetWithHttpInfo(string $contentType = self::contentTypes['reportsRestaurantsOrdersGet'][0])
    {
        $request = $this->reportsRestaurantsOrdersGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsRestaurantsOrdersGetAsync
     *
     * Generate a report of total orders received by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsOrdersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsRestaurantsOrdersGetAsync(string $contentType = self::contentTypes['reportsRestaurantsOrdersGet'][0])
    {
        return $this->reportsRestaurantsOrdersGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsRestaurantsOrdersGetAsyncWithHttpInfo
     *
     * Generate a report of total orders received by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsOrdersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsRestaurantsOrdersGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsRestaurantsOrdersGet'][0])
    {
        $returnType = '';
        $request = $this->reportsRestaurantsOrdersGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsRestaurantsOrdersGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsOrdersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsRestaurantsOrdersGetRequest(string $contentType = self::contentTypes['reportsRestaurantsOrdersGet'][0])
    {


        $resourcePath = '/reports/restaurants/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsRestaurantsRatingsGet
     *
     * Generate a report of average ratings of each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRatingsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsRestaurantsRatingsGet(string $contentType = self::contentTypes['reportsRestaurantsRatingsGet'][0])
    {
        $this->reportsRestaurantsRatingsGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsRestaurantsRatingsGetWithHttpInfo
     *
     * Generate a report of average ratings of each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRatingsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsRestaurantsRatingsGetWithHttpInfo(string $contentType = self::contentTypes['reportsRestaurantsRatingsGet'][0])
    {
        $request = $this->reportsRestaurantsRatingsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsRestaurantsRatingsGetAsync
     *
     * Generate a report of average ratings of each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRatingsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsRestaurantsRatingsGetAsync(string $contentType = self::contentTypes['reportsRestaurantsRatingsGet'][0])
    {
        return $this->reportsRestaurantsRatingsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsRestaurantsRatingsGetAsyncWithHttpInfo
     *
     * Generate a report of average ratings of each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRatingsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsRestaurantsRatingsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsRestaurantsRatingsGet'][0])
    {
        $returnType = '';
        $request = $this->reportsRestaurantsRatingsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsRestaurantsRatingsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRatingsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsRestaurantsRatingsGetRequest(string $contentType = self::contentTypes['reportsRestaurantsRatingsGet'][0])
    {


        $resourcePath = '/reports/restaurants/ratings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportsRestaurantsRevenueGet
     *
     * Generate a report of revenue generated by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRevenueGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportsRestaurantsRevenueGet(string $contentType = self::contentTypes['reportsRestaurantsRevenueGet'][0])
    {
        $this->reportsRestaurantsRevenueGetWithHttpInfo($contentType);
    }

    /**
     * Operation reportsRestaurantsRevenueGetWithHttpInfo
     *
     * Generate a report of revenue generated by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRevenueGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportsRestaurantsRevenueGetWithHttpInfo(string $contentType = self::contentTypes['reportsRestaurantsRevenueGet'][0])
    {
        $request = $this->reportsRestaurantsRevenueGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportsRestaurantsRevenueGetAsync
     *
     * Generate a report of revenue generated by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRevenueGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsRestaurantsRevenueGetAsync(string $contentType = self::contentTypes['reportsRestaurantsRevenueGet'][0])
    {
        return $this->reportsRestaurantsRevenueGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportsRestaurantsRevenueGetAsyncWithHttpInfo
     *
     * Generate a report of revenue generated by each restaurant
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRevenueGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportsRestaurantsRevenueGetAsyncWithHttpInfo(string $contentType = self::contentTypes['reportsRestaurantsRevenueGet'][0])
    {
        $returnType = '';
        $request = $this->reportsRestaurantsRevenueGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportsRestaurantsRevenueGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportsRestaurantsRevenueGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportsRestaurantsRevenueGetRequest(string $contentType = self::contentTypes['reportsRestaurantsRevenueGet'][0])
    {


        $resourcePath = '/reports/restaurants/revenue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsGet
     *
     * Get all restaurants
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Restaurant[]
     */
    public function restaurantsGet(string $contentType = self::contentTypes['restaurantsGet'][0])
    {
        list($response) = $this->restaurantsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restaurantsGetWithHttpInfo
     *
     * Get all restaurants
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Restaurant[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsGetWithHttpInfo(string $contentType = self::contentTypes['restaurantsGet'][0])
    {
        $request = $this->restaurantsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Restaurant[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Restaurant[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Restaurant[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Restaurant[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Restaurant[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsGetAsync
     *
     * Get all restaurants
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsGetAsync(string $contentType = self::contentTypes['restaurantsGet'][0])
    {
        return $this->restaurantsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsGetAsyncWithHttpInfo
     *
     * Get all restaurants
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsGetAsyncWithHttpInfo(string $contentType = self::contentTypes['restaurantsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Restaurant[]';
        $request = $this->restaurantsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsGetRequest(string $contentType = self::contentTypes['restaurantsGet'][0])
    {


        $resourcePath = '/restaurants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsPost
     *
     * Create a new restaurant
     *
     * @param  string $name name (optional)
     * @param  string $description description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location location (optional)
     * @param  string $opening_hours opening_hours (optional)
     * @param  string[] $delivery_areas delivery_areas (optional)
     * @param  \SplFileObject $image image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restaurantsPost($name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsPost'][0])
    {
        $this->restaurantsPostWithHttpInfo($name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType);
    }

    /**
     * Operation restaurantsPostWithHttpInfo
     *
     * Create a new restaurant
     *
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsPostWithHttpInfo($name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsPost'][0])
    {
        $request = $this->restaurantsPostRequest($name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsPostAsync
     *
     * Create a new restaurant
     *
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsPostAsync($name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsPost'][0])
    {
        return $this->restaurantsPostAsyncWithHttpInfo($name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsPostAsyncWithHttpInfo
     *
     * Create a new restaurant
     *
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsPostAsyncWithHttpInfo($name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsPost'][0])
    {
        $returnType = '';
        $request = $this->restaurantsPostRequest($name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsPost'
     *
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsPostRequest($name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsPost'][0])
    {








        $resourcePath = '/restaurants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($location !== null) {
            $formParams['location'] = ObjectSerializer::toFormValue($location);
        }
        // form params
        if ($opening_hours !== null) {
            $formParams['openingHours'] = ObjectSerializer::toFormValue($opening_hours);
        }
        // form params
        if ($delivery_areas !== null) {
            $formParams['deliveryAreas'] = ObjectSerializer::toFormValue($delivery_areas);
        }
        // form params
        if ($image !== null) {
            $multipart = true;
            $formParams['image'] = [];
            $paramFiles = is_array($image) ? $image : [$image];
            foreach ($paramFiles as $paramFile) {
                $formParams['image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdDelete
     *
     * Delete a restaurant
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restaurantsRestaurantIdDelete($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdDelete'][0])
    {
        $this->restaurantsRestaurantIdDeleteWithHttpInfo($restaurant_id, $contentType);
    }

    /**
     * Operation restaurantsRestaurantIdDeleteWithHttpInfo
     *
     * Delete a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdDeleteWithHttpInfo($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdDelete'][0])
    {
        $request = $this->restaurantsRestaurantIdDeleteRequest($restaurant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdDeleteAsync
     *
     * Delete a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdDeleteAsync($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdDelete'][0])
    {
        return $this->restaurantsRestaurantIdDeleteAsyncWithHttpInfo($restaurant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdDeleteAsyncWithHttpInfo
     *
     * Delete a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdDeleteAsyncWithHttpInfo($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdDelete'][0])
    {
        $returnType = '';
        $request = $this->restaurantsRestaurantIdDeleteRequest($restaurant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdDelete'
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdDeleteRequest($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdDelete'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdDelete'
            );
        }


        $resourcePath = '/restaurants/{restaurantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdGet
     *
     * Get a restaurant by ID
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Restaurant
     */
    public function restaurantsRestaurantIdGet($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdGet'][0])
    {
        list($response) = $this->restaurantsRestaurantIdGetWithHttpInfo($restaurant_id, $contentType);
        return $response;
    }

    /**
     * Operation restaurantsRestaurantIdGetWithHttpInfo
     *
     * Get a restaurant by ID
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Restaurant, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdGetWithHttpInfo($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdGet'][0])
    {
        $request = $this->restaurantsRestaurantIdGetRequest($restaurant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Restaurant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Restaurant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Restaurant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Restaurant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Restaurant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdGetAsync
     *
     * Get a restaurant by ID
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdGetAsync($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdGet'][0])
    {
        return $this->restaurantsRestaurantIdGetAsyncWithHttpInfo($restaurant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdGetAsyncWithHttpInfo
     *
     * Get a restaurant by ID
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdGetAsyncWithHttpInfo($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Restaurant';
        $request = $this->restaurantsRestaurantIdGetRequest($restaurant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdGet'
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdGetRequest($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdGet'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdGet'
            );
        }


        $resourcePath = '/restaurants/{restaurantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdMenusGet
     *
     * Get all menu items for a restaurant
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItem[]
     */
    public function restaurantsRestaurantIdMenusGet($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusGet'][0])
    {
        list($response) = $this->restaurantsRestaurantIdMenusGetWithHttpInfo($restaurant_id, $contentType);
        return $response;
    }

    /**
     * Operation restaurantsRestaurantIdMenusGetWithHttpInfo
     *
     * Get all menu items for a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdMenusGetWithHttpInfo($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusGet'][0])
    {
        $request = $this->restaurantsRestaurantIdMenusGetRequest($restaurant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItem[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItem[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItem[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItem[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdMenusGetAsync
     *
     * Get all menu items for a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusGetAsync($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusGet'][0])
    {
        return $this->restaurantsRestaurantIdMenusGetAsyncWithHttpInfo($restaurant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdMenusGetAsyncWithHttpInfo
     *
     * Get all menu items for a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusGetAsyncWithHttpInfo($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItem[]';
        $request = $this->restaurantsRestaurantIdMenusGetRequest($restaurant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdMenusGet'
     *
     * @param  string $restaurant_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdMenusGetRequest($restaurant_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusGet'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdMenusGet'
            );
        }


        $resourcePath = '/restaurants/{restaurantId}/menus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdDelete
     *
     * Delete a menu item
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $menu_id menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restaurantsRestaurantIdMenusMenuIdDelete($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'][0])
    {
        $this->restaurantsRestaurantIdMenusMenuIdDeleteWithHttpInfo($restaurant_id, $menu_id, $contentType);
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdDeleteWithHttpInfo
     *
     * Delete a menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdMenusMenuIdDeleteWithHttpInfo($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'][0])
    {
        $request = $this->restaurantsRestaurantIdMenusMenuIdDeleteRequest($restaurant_id, $menu_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdDeleteAsync
     *
     * Delete a menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusMenuIdDeleteAsync($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'][0])
    {
        return $this->restaurantsRestaurantIdMenusMenuIdDeleteAsyncWithHttpInfo($restaurant_id, $menu_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdDeleteAsyncWithHttpInfo
     *
     * Delete a menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusMenuIdDeleteAsyncWithHttpInfo($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'][0])
    {
        $returnType = '';
        $request = $this->restaurantsRestaurantIdMenusMenuIdDeleteRequest($restaurant_id, $menu_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdMenusMenuIdDelete'
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdMenusMenuIdDeleteRequest($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdDelete'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdMenusMenuIdDelete'
            );
        }

        // verify the required parameter 'menu_id' is set
        if ($menu_id === null || (is_array($menu_id) && count($menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $menu_id when calling restaurantsRestaurantIdMenusMenuIdDelete'
            );
        }


        $resourcePath = '/restaurants/{restaurantId}/menus/{menuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'menuId' . '}',
                ObjectSerializer::toPathValue($menu_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdGet
     *
     * Get a menu item by ID
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $menu_id menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MenuItem
     */
    public function restaurantsRestaurantIdMenusMenuIdGet($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'][0])
    {
        list($response) = $this->restaurantsRestaurantIdMenusMenuIdGetWithHttpInfo($restaurant_id, $menu_id, $contentType);
        return $response;
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdGetWithHttpInfo
     *
     * Get a menu item by ID
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MenuItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdMenusMenuIdGetWithHttpInfo($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'][0])
    {
        $request = $this->restaurantsRestaurantIdMenusMenuIdGetRequest($restaurant_id, $menu_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MenuItem' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MenuItem' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MenuItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MenuItem';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MenuItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdGetAsync
     *
     * Get a menu item by ID
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusMenuIdGetAsync($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'][0])
    {
        return $this->restaurantsRestaurantIdMenusMenuIdGetAsyncWithHttpInfo($restaurant_id, $menu_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdGetAsyncWithHttpInfo
     *
     * Get a menu item by ID
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusMenuIdGetAsyncWithHttpInfo($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MenuItem';
        $request = $this->restaurantsRestaurantIdMenusMenuIdGetRequest($restaurant_id, $menu_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdMenusMenuIdGet'
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdMenusMenuIdGetRequest($restaurant_id, $menu_id, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdGet'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdMenusMenuIdGet'
            );
        }

        // verify the required parameter 'menu_id' is set
        if ($menu_id === null || (is_array($menu_id) && count($menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $menu_id when calling restaurantsRestaurantIdMenusMenuIdGet'
            );
        }


        $resourcePath = '/restaurants/{restaurantId}/menus/{menuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'menuId' . '}',
                ObjectSerializer::toPathValue($menu_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdPut
     *
     * Update a menu item
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $menu_id menu_id (required)
     * @param  string $name name (optional)
     * @param  string $description description (optional)
     * @param  float $price price (optional)
     * @param  \SplFileObject $image image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restaurantsRestaurantIdMenusMenuIdPut($restaurant_id, $menu_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'][0])
    {
        $this->restaurantsRestaurantIdMenusMenuIdPutWithHttpInfo($restaurant_id, $menu_id, $name, $description, $price, $image, $contentType);
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdPutWithHttpInfo
     *
     * Update a menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdMenusMenuIdPutWithHttpInfo($restaurant_id, $menu_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'][0])
    {
        $request = $this->restaurantsRestaurantIdMenusMenuIdPutRequest($restaurant_id, $menu_id, $name, $description, $price, $image, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdPutAsync
     *
     * Update a menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusMenuIdPutAsync($restaurant_id, $menu_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'][0])
    {
        return $this->restaurantsRestaurantIdMenusMenuIdPutAsyncWithHttpInfo($restaurant_id, $menu_id, $name, $description, $price, $image, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdMenusMenuIdPutAsyncWithHttpInfo
     *
     * Update a menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusMenuIdPutAsyncWithHttpInfo($restaurant_id, $menu_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'][0])
    {
        $returnType = '';
        $request = $this->restaurantsRestaurantIdMenusMenuIdPutRequest($restaurant_id, $menu_id, $name, $description, $price, $image, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdMenusMenuIdPut'
     *
     * @param  string $restaurant_id (required)
     * @param  string $menu_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdMenusMenuIdPutRequest($restaurant_id, $menu_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusMenuIdPut'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdMenusMenuIdPut'
            );
        }

        // verify the required parameter 'menu_id' is set
        if ($menu_id === null || (is_array($menu_id) && count($menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $menu_id when calling restaurantsRestaurantIdMenusMenuIdPut'
            );
        }






        $resourcePath = '/restaurants/{restaurantId}/menus/{menuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }
        // path params
        if ($menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'menuId' . '}',
                ObjectSerializer::toPathValue($menu_id),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($price !== null) {
            $formParams['price'] = ObjectSerializer::toFormValue($price);
        }
        // form params
        if ($image !== null) {
            $multipart = true;
            $formParams['image'] = [];
            $paramFiles = is_array($image) ? $image : [$image];
            foreach ($paramFiles as $paramFile) {
                $formParams['image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdMenusPost
     *
     * Create a new menu item
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $name name (optional)
     * @param  string $description description (optional)
     * @param  float $price price (optional)
     * @param  \SplFileObject $image image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restaurantsRestaurantIdMenusPost($restaurant_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusPost'][0])
    {
        $this->restaurantsRestaurantIdMenusPostWithHttpInfo($restaurant_id, $name, $description, $price, $image, $contentType);
    }

    /**
     * Operation restaurantsRestaurantIdMenusPostWithHttpInfo
     *
     * Create a new menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdMenusPostWithHttpInfo($restaurant_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusPost'][0])
    {
        $request = $this->restaurantsRestaurantIdMenusPostRequest($restaurant_id, $name, $description, $price, $image, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdMenusPostAsync
     *
     * Create a new menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusPostAsync($restaurant_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusPost'][0])
    {
        return $this->restaurantsRestaurantIdMenusPostAsyncWithHttpInfo($restaurant_id, $name, $description, $price, $image, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdMenusPostAsyncWithHttpInfo
     *
     * Create a new menu item
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdMenusPostAsyncWithHttpInfo($restaurant_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusPost'][0])
    {
        $returnType = '';
        $request = $this->restaurantsRestaurantIdMenusPostRequest($restaurant_id, $name, $description, $price, $image, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdMenusPost'
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  float $price (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdMenusPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdMenusPostRequest($restaurant_id, $name = null, $description = null, $price = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdMenusPost'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdMenusPost'
            );
        }






        $resourcePath = '/restaurants/{restaurantId}/menus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($price !== null) {
            $formParams['price'] = ObjectSerializer::toFormValue($price);
        }
        // form params
        if ($image !== null) {
            $multipart = true;
            $formParams['image'] = [];
            $paramFiles = is_array($image) ? $image : [$image];
            foreach ($paramFiles as $paramFile) {
                $formParams['image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restaurantsRestaurantIdPut
     *
     * Update a restaurant
     *
     * @param  string $restaurant_id restaurant_id (required)
     * @param  string $name name (optional)
     * @param  string $description description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location location (optional)
     * @param  string $opening_hours opening_hours (optional)
     * @param  string[] $delivery_areas delivery_areas (optional)
     * @param  \SplFileObject $image image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restaurantsRestaurantIdPut($restaurant_id, $name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdPut'][0])
    {
        $this->restaurantsRestaurantIdPutWithHttpInfo($restaurant_id, $name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType);
    }

    /**
     * Operation restaurantsRestaurantIdPutWithHttpInfo
     *
     * Update a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restaurantsRestaurantIdPutWithHttpInfo($restaurant_id, $name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdPut'][0])
    {
        $request = $this->restaurantsRestaurantIdPutRequest($restaurant_id, $name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restaurantsRestaurantIdPutAsync
     *
     * Update a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdPutAsync($restaurant_id, $name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdPut'][0])
    {
        return $this->restaurantsRestaurantIdPutAsyncWithHttpInfo($restaurant_id, $name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restaurantsRestaurantIdPutAsyncWithHttpInfo
     *
     * Update a restaurant
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restaurantsRestaurantIdPutAsyncWithHttpInfo($restaurant_id, $name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdPut'][0])
    {
        $returnType = '';
        $request = $this->restaurantsRestaurantIdPutRequest($restaurant_id, $name, $description, $location, $opening_hours, $delivery_areas, $image, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restaurantsRestaurantIdPut'
     *
     * @param  string $restaurant_id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  \OpenAPI\Client\Model\RestaurantsPostRequestLocation $location (optional)
     * @param  string $opening_hours (optional)
     * @param  string[] $delivery_areas (optional)
     * @param  \SplFileObject $image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restaurantsRestaurantIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restaurantsRestaurantIdPutRequest($restaurant_id, $name = null, $description = null, $location = null, $opening_hours = null, $delivery_areas = null, $image = null, string $contentType = self::contentTypes['restaurantsRestaurantIdPut'][0])
    {

        // verify the required parameter 'restaurant_id' is set
        if ($restaurant_id === null || (is_array($restaurant_id) && count($restaurant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restaurant_id when calling restaurantsRestaurantIdPut'
            );
        }








        $resourcePath = '/restaurants/{restaurantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($restaurant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'restaurantId' . '}',
                ObjectSerializer::toPathValue($restaurant_id),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($location !== null) {
            $formParams['location'] = ObjectSerializer::toFormValue($location);
        }
        // form params
        if ($opening_hours !== null) {
            $formParams['openingHours'] = ObjectSerializer::toFormValue($opening_hours);
        }
        // form params
        if ($delivery_areas !== null) {
            $formParams['deliveryAreas'] = ObjectSerializer::toFormValue($delivery_areas);
        }
        // form params
        if ($image !== null) {
            $multipart = true;
            $formParams['image'] = [];
            $paramFiles = is_array($image) ? $image : [$image];
            foreach ($paramFiles as $paramFile) {
                $formParams['image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
